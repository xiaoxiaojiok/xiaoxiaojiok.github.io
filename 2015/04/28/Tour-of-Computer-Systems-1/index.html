

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>计算机系统漫游 | 磕了药的手风琴</title>
  <meta name="author" content="coderxiao">
  
  <meta name="description" content="xiaojian">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="计算机系统漫游"/>
  <meta property="og:site_name" content="磕了药的手风琴"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="磕了药的手风琴" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
  


  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?c76af951f22ae474d54aa5de7f5928cd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  <meta name="baidu-site-verification" content="T5wrOARbB1" />
</head>


<body>
  <header id="header" class="inner">
<div class="alignleft">
  <h1><a href="/">磕了药的手风琴</a></h1>
  <h2><a href="/">有优秀的人在，在哪里都能取得进步</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
<li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

<li></li>
<li></li>
<li></li>
<li></li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-28T12:31:11.000Z"><a href="/2015/04/28/Tour-of-Computer-Systems-1/">4月 28 2015</a></time>
      
      
  
    <h1 class="title">计算机系统漫游</h1>
  

    </header>
    <div class="entry">
      
        <h2>从开机说起</h2>

<hr>
<p>当我们按下计算机的电源开关时候，计算机首先会自动从主板的<a href="http://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="external">BIOS</a>（基本输入输出系统）读取其中存储的程序。</p>
<p>它引导各个组件如内存、显卡开始运行，允许你从软盘、光盘或者硬盘中选择一个来启动计算机，之后将控制权移交给正常启动的主操作系统。</p>
<p>首先BIOS将从你所选择的存储设备中读取<code>起始的512bytes</code>(比如光盘一开始的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做<code>主引导记录MBR</code> (master boot record)。MBR会告诉电脑从该设备的<code>某一个分区</code>(partition)来装载<code>引导加载程序</code>(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有<code>GRUB</code>和<code>LILO</code>。</p>
<p>随后，boot loader会帮助我们<code>加载kernel</code>。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<a id="more"></a>

<p>实际上，我们可以在<code>多个分区安装boot loader</code>，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是<code>多操作系统</code>的原理。</p>
<p>如果我们加载的是<code>Linux kernel</code>，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过<code>驱动程序</code>(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个<code>init进程</code>。它是Linux系统中的1号进程。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>随后，init会运行一系列的<code>初始脚本</code>(startup scripts)，这些脚本是Linux中常见的shell scripts。</p>
<p>这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等等。</p>
<p>当运行完这些初始脚本，操作系统已经完全准备好了，就等待用户进行登录操作。</p>
<h3>小结</h3>

<p>电源 -&gt; <strong>BIOS</strong> -&gt; <strong>MBR</strong> -&gt; <strong>boot loader</strong> -&gt; <strong>kernel</strong> -&gt; <strong>init process</strong> -&gt; <strong>login</strong></p>
<h2>追踪HelloWorld程序</h2>

<hr>
<p>好了，既然计算机已经打开了，我们就让它做点事情。</p>
<p>我们将通过追踪一个HelloWorld程序的生命周期来漫游计算机系统——从它被程序员创建，到系统上运行，以及输出简单的消息，然后终止。</p>
<p>下面是一个经典的HelloWorld程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hello.c</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>信息=位+上下文</h3><br>hello程序的生命周期是从一个源文件开始的，就是程序员利用编辑器创建并保存的文本文件，文件名字为hello.c。源程序实际上就是一个由值0和1组成的位序列，每8个位被组织成一组，称为字节。每个字节表示程序中的某一个字符。<br><br>大部分现代系统都使用<code>ASCII</code>标准来表示文本字符，这种方式实际上是用一个唯一的单字节大小的整数值（注意这个整数值其实就是由0和1的编码表示）来表示每个字符。<br><br>下面就是hello.c程序的ASCII码表示。<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloASCII.png" alt=""><br><br>像hello.c这样只由ASCII字符构成的文件称为<code>文本文件</code>，所有其他文件称为<code>二进制文件</code>。<br><br>hello.c的表示方法说明了一个基本的思想：<br><br><strong>计算机系统中所有信息——包括磁盘文件、存储器中的程序、存储器中存放的数据以及网络上传送的数据，都是由一串位来表示的。</strong><br><br>区分不同的数据对象的唯一方法是我们读到这些数据对象的<strong>上下文</strong>。比如，在不同的上下文中，一个同样的字节序列可能表示一个<code>整数、浮点数、字符串或者机器指令</code>。<br><br><h3>预处理、编译、汇编和链接</h3><br>为了可以在计算机上面运行hello.c程序，每一条C语句都必须被程序转换成一系列的<code>低级机器语言指令</code>。<br><br>然后这些指令按照一种称为可执行目标程序的格式打包好，并以二进制磁盘的文件的形式存放起来。<code>目标文件</code>也称为<code>可执行文件</code>。<br><br>在Linux上可以通过GCC编译器经过四个阶段得到可执行文件:<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloCompile.png" alt=""><br><br>1.<code>预处理</code>：处理#include，读取头文件stdio.h内容并将其插入到hello.c中，这样得到另一个程序hello.i。<br>    <strong>gcc -E hello.c  -&gt; hello.i</strong><br>2.<code>编译</code>：将hello.i翻译成汇编语言程序hello.s。<br>    <strong>gcc -S hello.i  -&gt; hello.s</strong><br>3.<code>汇编</code>：将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标文件的格式，它的字节编码是机器语言指令而不是字符，所以打开hello.o将得到一堆乱码。<br>    <strong>gcc -c hello.s  -&gt; hello.o</strong><br>4.<code>链接</code>：hello程序调用了printf函数，printf函数存在于一个名字为printf.o的单独编译好的目标文件中，我们的程序必须将它合并到hello.o中，得到最终的可执行目标文件hello，它可以被加载到内存中，由系统执行。<br>    <strong>gcc -o hello.o  -&gt; hello</strong><br><br><h3>运行Hello World程序</h3><br>在得到的<code>hello</code>可执行文件同一目录下，我们在键盘中输入字符串<code>./hello</code>，shell程序将字符逐一读入寄存器，再把它放到存储器中，如下所示：<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun1.png" alt=""><br><br>当我们在键盘上面敲下回车时，shell程序就会知道我们已经结束了命令的输入，然后shell程序执行一系列的指令来加载hello可执行文件，并将hello中的代码和数据<code>从磁盘复制到主存中</code>。<br><br>一旦目标文件hello中的代码和数据被加载到内存，处理器就开始执行hello程序的main程序中的机器语言指令。<br><br>这些指令将<code>Hello World\n</code>字符串中的字节<code>从主存复制到寄存器文件</code>，再<code>从寄存器文件复制到显示设备</code>，最终显示在屏幕上。步骤如下：<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun2.png" alt=""><br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun3.png" alt=""><br><br><br><h3>高速缓存</h3>

<p>上面的展示揭露了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另外一个地方。</p>
<p>hello程序的机器指令从磁盘复制到主存，又从主存复制到处理器。而数据串<code>Hello World\n</code>则从磁盘复制到主存，又从主存复制到显示设备。</p>
<p>为了协调CPU和主存之间的差异和利用计算机的局部性原理，系统采用了更小更快的存储设备，即高速缓存存储器。如下所示：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloCache.png" alt=""></p>
<p>主要思想是<code>高一层的存储器作为低一层存储器的高速缓存</code>。在某些具有分布式文件系统的网络系统中，<code>本地磁盘就是存储在其他系统磁盘的数据的高速缓存</code>。</p>
<p><h3>操作系统提供的抽象</h3><br>抽象是计算机科学中最为重要的概念之一。</p>
<p>操作系统为我们提供了几个重要的抽象：</p>
<ol>
<li><code>文件</code>：文件是对IO设备的抽象。</li>
<li><code>进程</code>:对处理器、主存和IO设备的抽象。<strong>进程是程序的一次执行</strong>。</li>
<li><code>虚拟存储器</code>：对主存和磁盘IO设备的抽象。</li>
<li><code>虚拟机</code>：提供了对这个计算机（包括操作系统、处理器和程序）的抽象。</li>
</ol>
<h4>进程</h4>

<p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上面可以同时运行多个进程，而每个进程都好像是在独占地使用硬件。</p>
<p>一个CPU看上去都像在并发执行多个进程，这是<code>由于CPU在进程间快速切换实现</code>的。</p>
<p>操作系统保持追踪进程运行所需要的所有状态的信息。这种状态，也就是<strong>上下文</strong>，它包括许多信息，例如PC、寄存器信息等。</p>
<p>在任何一个时刻，单处理器系统只能执行一个程序的代码。</p>
<p>当操作系统决定要把控制权从当前进程转移到某一个新的进程的时候，就会发生上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后把控制权传递给新进程。</p>
<p>我们的shell程序作为A进程以及hello程序作为B进程，上下文切换如下所示：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloProess.png" alt=""></p>
<p>通常内核中会使用<code>进程表</code>来保存进程的上下文。</p>
<p>进程表中的内容如下：</p>
<ol>
<li><code>进程管理</code>相关：PC、寄存器、程序状态字、进程状态、优先级、调度参数、pid、ppid、pgid、信号、信号屏蔽字、CPU时间、启动时间等；</li>
<li><code>内存管理</code>相关：指向正文段的指针、指向数据段的指针、指向堆栈段的指针</li>
<li><code>文件管理</code>相关：根目录、工作目录、文件描述符表、用户ID、组ID</li>
</ol>
<h4>虚拟存储器</h4>

<p>在早期的计算机中，程序是直接运行在物理内存上的。换句话说，就是程序在运行的过程中访问的都是物理地址。</p>
<p>如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就一个程序，就这么点内存，用不用完那是程序自身的事情。</p>
<p>然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为内存管理。</p>
<p>下面举一个早期的计算机系统中，内存分配管理的例子，以便于大家理解。</p>
<p>假如我们有三个程序，程序A、B、C。</p>
<p>程序A运行的过程中需要10M内存，程序B运行的过程中需要100M内存，而程序C运行的过程中需要20M内存。</p>
<p>如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A, 接下来的10M-110M分配给B。</p>
<p>现在假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。</p>
<p>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>下面我们来看看这种内存管理方式存在的几个比较明显的问题。</p>
<ol>
<li><code>进程地址空间不能隔离</code><br>由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃。这样很多恶意程序或者是木马程序可以轻而易举的破坏其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</li>
<li><code>内存使用的效率低</code><br>如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。</li>
<li><code>程序运行的地址不能确定</code><br>程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址。</li>
</ol>
<p>那么怎么解决上面这三个问题呢？</p>
<p>有人说过：<strong>计算机系统里的任何问题都可以靠引入一个中间层来解决。</strong></p>
<p>现在的内存管理方法就是在程序和物理内存之间引入了虚拟内存这个概念。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</p>
<p>既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有<code>分段</code>和<code>分页</code>两种技术。</p>
<p><code>分段(Segmentation)</code>：这种方法是人们最开始使用的一种方法，基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个<br>物理地址空间。</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloSeg1.png" alt=""></p>
<p>每个程序都有其独立的进程地址空间，可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。</p>
<p>我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。</p>
<p>这种分段的机制<code>解决了</code>文章一开始提到的3个问题中的<code>进程地址空间隔离和程序地址重定位的问题</code>。</p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。</p>
<p>程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。因为这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。</p>
<p>那么，怎么才算高效率的内存使用呢?</p>
<p>事实上，根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。所以我们需要更加小粒度的内存分割和映射方法，另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<p><code>分页</code>：分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。</p>
<p>试想以下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999K字节是不是浪费了。</p>
<p>Linux中一般页的大小是4KB，我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，如下图：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloSeg2.png" alt=""></p>
<p>我们可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内。</p>
<p>这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行。</p>
<p>甚至他们共用了一部分物理地址空间，这就是<code>共享内存</code>的概念了。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个<code>缺页异常</code>，然后异常管理程序会将其读到内存中。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<code>MMU(Memory Management Unit)</code>，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p>这个就是虚拟存储器的具体原理了。</p>
<h2>参考</h2>

<hr>
<p><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective</a>这是一本跨越编译原理、操作系统、计算机体系结构等多个学科的深入了解计算机系统的殿堂级著作。</p>
<p><a href="http://book.douban.com/subject/3652388/" target="_blank" rel="external">程序员的自我修养:链接、装载和库</a>程序员内功修炼。</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Linux/">Linux</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Linux/">Linux</a>
  </div>

<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare">
<a class="bds_qzone"></a>
<a class="bds_tsina"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_t163"></a>
<span class="bds_more"></span>
<a class="shareCount"></a>
</div>
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=3326447" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination" >
    
    <a href="/2015/05/13/Dubbo-distributed-service1/" class="alignleft prev" title="基于Dubbo的分布式服务">上一篇：基于Dubbo的分布式服务</a>
 	
 	
    <a href="/2015/04/19/Depth-in-Singleton/" class="alignright next" title="深入了解单例模式">下一篇：深入了解单例模式</a>
 	
    <div class="clearfix"></div>

</nav>


<section id="comment">

<!-- Duoshuo Comment BEGIN -->
	<div class="ds-thread" data-thread-key="/2015/04/28/Tour-of-Computer-Systems-1/" data-title="计算机系统漫游" data-url="http://coderxiao.com/2015/04/28/Tour-of-Computer-Systems-1/"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"xiaoxiaojiok"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Duoshuo Comment END -->  

  
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//baidu.com/baidu" method="get" accept-charset="utf-8">
    <input type="search" name="word" results="0" placeholder="搜索">
    <input type="hidden" name="si" value="coderxiao.com">
    <input name=tn type=hidden value="bds">
	<input name=cl type=hidden value="3">
	<input name=ct type=hidden value="2097152">
	<input name=s type=hidden value="on">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Algorithm/">Algorithm</a><small>1</small></li>
  
    <li><a href="/categories/C/">C++</a><small>1</small></li>
  
    <li><a href="/categories/Dubbo/">Dubbo</a><small>1</small></li>
  
    <li><a href="/categories/Hexo/">Hexo</a><small>1</small></li>
  
    <li><a href="/categories/Java/">Java</a><small>19</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>5</small></li>
  
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">简介</h3>
<ul class="entry">
<li>磕了药的手风琴</li>
<li><a href="http://www.scut.edu.cn">SCUT</a>在读研究生</li>
<li>Theme: <a href="https://github.com/xiaoxiaojiok/light">Light</a></li>
<li>想要交友的朋友请<a href="http://coderxiao.com/about">联系我</a>！</li>
</ul>
</div>



  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Algorithm/" style="font-size: 10.00px;">Algorithm</a><a href="/tags/C/" style="font-size: 10.00px;">C++</a><a href="/tags/CGI/" style="font-size: 10.00px;">CGI</a><a href="/tags/Design-Pattern/" style="font-size: 12.50px;">Design Pattern</a><a href="/tags/Dubbo/" style="font-size: 10.00px;">Dubbo</a><a href="/tags/Git/" style="font-size: 10.00px;">Git</a><a href="/tags/Hexo/" style="font-size: 10.00px;">Hexo</a><a href="/tags/Java/" style="font-size: 20.00px;">Java</a><a href="/tags/Linux/" style="font-size: 15.00px;">Linux</a><a href="/tags/Thread/" style="font-size: 17.50px;">Thread</a><a href="/tags/shell/" style="font-size: 10.00px;">shell</a>
  </div>
</div>


  <iframe width="100%" height="137" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=137&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2552916352&verifier=fbb51242&dpc=1"></iframe>

  <div class="widget tag">
<h3 class="title">亲，记得运动</h3>
<ul class="entry">
<object type="application/x-shockwave-flash" style="outline:none;" 
data="http://cdn-blog.mimvp.com/wp-content/themes/officefolders/images/mouse.swf" 
width="230" height="160" alt="显示小白鼠，请安装flash" title="小白鼠一枚，来领走我">
            <param name="movie" value="http://cdn-blog.mimvp.com/wp-content/themes/officefolders/images/mouse.swf" />
            <param name="bgcolor" value="#ffffff" />
                <param name="color" value="#F5F5F5" />
            <param name="AllowScriptAccess" value="always" />
            <param name="wmode" value="opaque" />
</object>
</ul>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://coolshell.cn/" title="coolshell.cn">酷壳网</a></li>
<li><a href="https://coderq.com" title="coderq.com">码农圈</a></li>
<li><a href="http://www.williamlong.info/" title="williamlong.info">月光博客</a></li>

</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 coderxiao
  
</div>
<div class="clearfix"></div></footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>




</body>
</html>



<a href="https://github.com/xiaoxiaojiok"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"></a>
