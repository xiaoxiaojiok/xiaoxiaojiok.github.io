<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[磕了药的手风琴]]></title>
  <subtitle><![CDATA[有优秀的人在，在哪里都能取得进步]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://coderxiao.com/"/>
  <updated>2015-12-16T16:02:54.311Z</updated>
  <id>http://coderxiao.com/</id>
  
  <author>
    <name><![CDATA[coderxiao]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[由一个C++单例模式引出的易错点]]></title>
    <link href="http://coderxiao.com/2015/05/21/C++_Singelton/"/>
    <id>http://coderxiao.com/2015/05/21/C++_Singelton/</id>
    <published>2015-05-21T07:47:26.000Z</published>
    <updated>2015-12-16T15:51:33.000Z</updated>
    <content type="html"><![CDATA[<h2>基于模板的单例模式</h2>

<hr>
<p>在用C++实现一个单例模式里，发现在调试程序的时候获取到的不是同一个实例，原来代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Singelton.h</span></div><div class="line"></div><div class="line"><span class="comment">//使用模板实现一个多线程安全的单例模式</span></div><div class="line"><span class="preprocessor">#ifndef SINGELTON_H</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> SINGELTON_H</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line">mutex mtx;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Lock</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	mutex *mtx;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">explicit</span> Lock(mutex *mtx) :mtx(mtx)</div><div class="line">	{</div><div class="line">		<span class="keyword">this</span>-&gt;mtx-&gt;lock();</div><div class="line">	}</div><div class="line">	~Lock()</div><div class="line">	{</div><div class="line">		<span class="keyword">this</span>-&gt;mtx-&gt;unlock();</div><div class="line">	}</div><div class="line">};</div></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</div><div class="line"><span class="keyword">class</span> Singelton</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	Singelton(){ }</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">static</span> Type *instance;</div><div class="line">	<span class="keyword">static</span> Type &me()</div><div class="line">	{</div><div class="line">		<span class="keyword">if</span> (instance == NULL)</div><div class="line">		{</div><div class="line">			Lock lock(&mtx);</div><div class="line">			<span class="comment">//double check</span></div><div class="line">			<span class="keyword">if</span> (instance == NULL)</div><div class="line">			{</div><div class="line">				instance = <span class="keyword">new</span> Type();</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> *instance;</div><div class="line">	}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</div><div class="line">Type *Singelton&lt;Type&gt;::instance = NULL;</div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">//SINGELTON_H</span></span></div></pre></td></tr></table></figure>

<p>测试程序如下：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Main.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;thread&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> "Singelton.h"</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> User</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">string</span> name;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	User(<span class="built_in">string</span> name = <span class="string">"Init"</span>):name(name)</div><div class="line">	{</div><div class="line">	}</div><div class="line">	<span class="built_in">string</span> getName()</div><div class="line">	{</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> setName(<span class="built_in">string</span> name)</div><div class="line">	{</div><div class="line">		<span class="keyword">this</span>-&gt;name = name;</div><div class="line">	}</div><div class="line"></div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> testSingelton()</div><div class="line">{</div><div class="line">	User user1 = Singelton&lt;User&gt;::me();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; &user1 &lt;&lt; endl;</div><div class="line">	User user2 = Singelton&lt;User&gt;::me();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; &user1 &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="stl_container"><span class="built_in">vector</span>&lt;thread&gt;</span> threads;</div><div class="line">	<span class="keyword">const</span> size_t total = <span class="number">3</span>;</div><div class="line">		<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; total; i++)</div><div class="line">	{</div><div class="line">		threads.push_back(thread(testSingelton));</div><div class="line">	}</div><div class="line">	<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; threads.size(); i++)</div><div class="line">	{</div><div class="line">		threads[i].join();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">0098F</span>484</div><div class="line"><span class="number">00</span>DDF81C</div><div class="line"><span class="number">006</span>DCC70</div><div class="line"><span class="number">004F</span>7A9C</div><div class="line"><span class="number">0010F</span>3F0</div><div class="line"><span class="number">00</span>CCF853</div></pre></td></tr></table></figure>

<p>明显得到的不是同一个对象</p>
<p>查看代码发现原来少了一个引用符号，这样的话<code>User</code>将会调用复制构造函数得到两个新的对象给<code>user1</code>和<code>user2</code></p>
<p>修改为：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> testSingelton()</div><div class="line">{</div><div class="line">	<span class="comment">//必须引用，否则将会调用复制构造函数</span></div><div class="line">	User &user1 = Singelton&lt;User&gt;::me();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; &user1 &lt;&lt; endl;</div><div class="line">	User &user2 = Singelton&lt;User&gt;::me();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; &user2 &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这时候打印的是同一个对象了</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">00626118</span></div><div class="line"><span class="number">00626118</span></div><div class="line"><span class="number">00626118</span></div><div class="line"><span class="number">00626118</span></div><div class="line"><span class="number">00626118</span></div><div class="line"><span class="number">00626118</span></div></pre></td></tr></table></figure>

<p><strong>也可以返回指针的方式，这样将不容易出错</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>基于模板的单例模式</h2>

<hr>
<p>在用C++实现一个单例模式里，发现在调试程序的时候获取到的不是同一个实例，原来代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Singelton.h</span></div><div class="line"></div><div class="line"><span class="comment">//使用模板实现一个多线程安全的单例模式</span></div><div class="line"><span class="preprocessor">#ifndef SINGELTON_H</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> SINGELTON_H</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;mutex&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line">mutex mtx;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Lock</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	mutex *mtx;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">explicit</span> Lock(mutex *mtx) :mtx(mtx)</div><div class="line">	{</div><div class="line">		<span class="keyword">this</span>-&gt;mtx-&gt;lock();</div><div class="line">	}</div><div class="line">	~Lock()</div><div class="line">	{</div><div class="line">		<span class="keyword">this</span>-&gt;mtx-&gt;unlock();</div><div class="line">	}</div><div class="line">};</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="C++" scheme="http://coderxiao.com/tags/C/"/>
    
      <category term="Design Pattern" scheme="http://coderxiao.com/tags/Design-Pattern/"/>
    
      <category term="C++" scheme="http://coderxiao.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Dubbo的分布式服务]]></title>
    <link href="http://coderxiao.com/2015/05/13/Dubbo-distributed-service1/"/>
    <id>http://coderxiao.com/2015/05/13/Dubbo-distributed-service1/</id>
    <published>2015-05-13T05:31:11.000Z</published>
    <updated>2015-12-16T15:57:51.000Z</updated>
    <content type="html"><![CDATA[<h2>Dubbo简介</h2>

<hr>
<p><code>Dubbo</code>是一个分布式服务框架，致力于提供高性能和透明化的<code>RPC</code>远程服务调用方案，以及<code>SOA</code>服务治理方案。</p>
<p>简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东西，其实就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册并调用）。</p>
<p>其核心部分包含:</p>
<ol>
<li><code>远程通讯</code><br>提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li><code>集群容错</code><br>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li><code>自动发现</code><br>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器</li>
</ol>
<a id="more"></a>

<h2>Dubbo使用</h2>

<hr>
<p><strong>注册中心</strong>：Dubbo将注册中心进行抽象，使得它可以外接不同的存储媒介给注册中心提供服务，有<code>ZooKeeper</code>，<code>Memcached</code>，<code>Redis</code>等。</p>
<p>这里将采用zookeeper的方式作为注册中心。</p>
<p><strong>接口和实现分离</strong>：为了达到分布式服务的作用，下面将会对接口和服务分别建立不同的项目，然后在实现处引用接口。</p>
<h3>定义分布式服务</h3>

<p>建立一个<em>TestAttach-api</em>的项目作为接口的定义。</p>
<p>接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.attachment;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Attachment</span> </span>{</div><div class="line">	String getAttachmentById (String Id);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>实现分布式服务</h3><br>建立一个<em>TestAttach-service</em>的项目作为接口的实现，提供服务。<br><br>写一个实现类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.attachment.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</div><div class="line"><span class="keyword">import</span> com.test.attachment.Attachment;</div><div class="line"></div><div class="line"><span class="annotation">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachmentImpl</span> <span class="keyword">implements</span> <span class="title">Attachment</span> </span>{</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> String <span class="title">getAttachmentById</span> (String Id){</div><div class="line">		<span class="keyword">return</span> <span class="string">"Attachment: "</span> + Id;</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure><br><br>建立三个dubbo的配置文件，放在<code>stc/main/resources</code>资源文件夹<br><br><strong>dubbo.properties</strong><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dubbo.container=spring</div><div class="line">dubbo.shutdown.hook=<span class="literal">true</span></div><div class="line">dubbo.spring.config=spring.xml</div></pre></td></tr></table></figure><br><br><strong>env.properties</strong><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dubbo.application.name=TestAttach-service</div><div class="line">dubbo.application.port=<span class="number">8889</span></div><div class="line">dubbo.registry.address=zookeeper://<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2181</span>?backup=<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2182</span>,<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2183</span></div><div class="line">dubbo.registry.timeout=<span class="number">10000</span></div></pre></td></tr></table></figure><br><br><strong>spring.xml</strong><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">	xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </div><div class="line">	xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">	http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">	http://www.springframework.org/schema/context   </div><div class="line">	http://www.springframework.org/schema/context/spring-context-3.2.xsd   </div><div class="line">	http://code.alibabatech.com/schema/dubbo</div><div class="line">	http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line"></div><div class="line">	&lt;context:property-placeholder location=<span class="string">"env.properties"</span> /&gt; </div><div class="line">    </div><div class="line">	</div><div class="line">	&lt;dubbo:application name=<span class="string">"<span class="variable">${dubbo.application.name}</span>"</span> /&gt;</div><div class="line">	&lt;dubbo:registry address=<span class="string">"<span class="variable">${dubbo.registry.address}</span>"</span> timeout=<span class="string">"<span class="variable">${dubbo.registry.timeout}</span>"</span> /&gt;</div><div class="line">	&lt;dubbo:protocol name=<span class="string">"dubbo"</span> server=<span class="string">"netty"</span>/&gt;</div><div class="line"> 	&lt;dubbo:provider id=<span class="string">"default"</span> port=<span class="string">"<span class="variable">${dubbo.application.port}</span>"</span> protocol=<span class="string">"dubbo"</span> /&gt;</div><div class="line">	&lt;dubbo:monitor protocol=<span class="string">"registry"</span> /&gt;</div><div class="line">	&lt;dubbo:annotation package=<span class="string">"com.test.attachment"</span> /&gt;</div><div class="line">	 </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure><br><br>在<code>Maven</code>的配置中加入对API的引用<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;dubbo&lt;/artifactId&gt; </div><div class="line">		&lt;version&gt;2.5.3&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;com.test.attachment&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;TestAttach-api&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.0.0&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;zkclient&lt;/artifactId&gt; </div><div class="line">		&lt;version&gt;0.5&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure><br><br>写一个服务的启动类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.attachment;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartDebug</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		com.alibaba.dubbo.container.Main.main(args);</div><div class="line">	} </div><div class="line">}</div></pre></td></tr></table></figure><br><br>运行<code>StartDebug</code>，启动服务<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">log4j:WARN No appenders could be found <span class="keyword">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).</div><div class="line">log4j:WARN Please initialize the log4j system properly.</div><div class="line">[<span class="number">2015</span>-<span class="number">12</span>-<span class="number">16</span> <span class="number">14</span>:<span class="number">14</span>:<span class="number">30</span>] Dubbo service server started!</div></pre></td></tr></table></figure><br><br><h3>客户端测试</h3>

<p>建立一个<em>TestAttach-client</em>的项目作为服务的测试客户端。</p>
<p>建立dubbo的配置文件，放在<code>stc/main/resources</code>资源文件夹</p>
<p><strong>dubbo.properties</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dubbo.container=spring</div><div class="line">dubbo.shutdown.hook=<span class="literal">true</span></div><div class="line">dubbo.spring.config=spring.xml</div><div class="line"></div><div class="line">dubbo.application.name=TestAttach-client</div><div class="line">dubbo.registry.address=zookeeper://<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2181</span>?backup=<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2182</span>,<span class="number">198.11</span>.<span class="number">180.44</span>:<span class="number">2183</span></div><div class="line">dubbo.registry.timeout=<span class="number">10000</span></div></pre></td></tr></table></figure>

<p><strong>spring.xml</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</div><div class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">	xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </div><div class="line">	xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	xmlns:dubbo=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">	xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">	http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">	http://www.springframework.org/schema/context   </div><div class="line">	http://www.springframework.org/schema/context/spring-context-3.2.xsd   </div><div class="line">	http://code.alibabatech.com/schema/dubbo</div><div class="line">	http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line"> </div><div class="line">  </div><div class="line">	&lt;dubbo:monitor protocol=<span class="string">"registry"</span> /&gt;</div><div class="line"> </div><div class="line">	&lt;dubbo:annotation package=<span class="string">"com.test.attachment"</span> /&gt;</div><div class="line">	 </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>

<p><code>Maven</code>配置和上面服务实现类同</p>
<p>写一个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test.attachment.client;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</div><div class="line"><span class="keyword">import</span> com.test.attachment.Attachment; </div><div class="line"></div><div class="line"><span class="annotation">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachmentClientDemo</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>{</div><div class="line">	<span class="annotation">@Reference</span></div><div class="line">	<span class="keyword">private</span> Attachment test;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Attachment <span class="title">getTest</span>(){</div><div class="line">		<span class="keyword">return</span> test;</div><div class="line">	}</div><div class="line">  </div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span>() <span class="keyword">throws</span> Exception {</div><div class="line">	    System.out.println(getTest().getAttachmentById(<span class="string">"3"</span>));</div><div class="line">		System.in.read();<span class="comment">//等待输入，使得客户端不退出</span></div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		com.alibaba.dubbo.container.Main.main(args);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>启动测试类，调用远程服务，输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">log4j:WARN No appenders could be found <span class="keyword">for</span> logger (com.alibaba.dubbo.common.logger.LoggerFactory).</div><div class="line">log4j:WARN Please initialize the log4j system properly.</div><div class="line">Attachment: <span class="number">3</span></div></pre></td></tr></table></figure>

<p><h3>Dubbo Admin</h3><br>现在可以方便在Dubbo控制台上看到我们服务的提供者和消费者了（<code>见参考</code>）</p>
<!-- ![](http://7tsz8h.com1.z0.glb.clouddn.com/dubbo-service.png)

![](http://7tsz8h.com1.z0.glb.clouddn.com/dubbo-client.png)

![](http://7tsz8h.com1.z0.glb.clouddn.com/dubbo-app.png) -->


<h2>参考</h2>

<hr>
<p><a href="http://dubbo.io/" target="_blank" rel="external">http://dubbo.io/</a>Dubbo官方网站</p>
<p><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo源码</a>Dubbo的Github地址</p>
<p><a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">Dubbo扩展</a>当当网开源Dubbox，扩展Dubbo服务框架支持REST风格远程调用</p>
<p><a href="http://download.csdn.net/detail/liuweiqiang_neu/8086929" target="_blank" rel="external">Dubbo控制台</a>Dubbo控制台项目包下载</p>
<p><a href="https://github.com/alibaba/dubbo/issues/50" target="_blank" rel="external">Dubbo控制台报错解决方案</a>Dubbo控制台项目和JDK兼容问题解决方案</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>Dubbo简介</h2>

<hr>
<p><code>Dubbo</code>是一个分布式服务框架，致力于提供高性能和透明化的<code>RPC</code>远程服务调用方案，以及<code>SOA</code>服务治理方案。</p>
<p>简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东西，其实就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册并调用）。</p>
<p>其核心部分包含:</p>
<ol>
<li><code>远程通讯</code><br>提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li><code>集群容错</code><br>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li><code>自动发现</code><br>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器</li>
</ol>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Dubbo" scheme="http://coderxiao.com/tags/Dubbo/"/>
    
      <category term="Dubbo" scheme="http://coderxiao.com/categories/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机系统漫游]]></title>
    <link href="http://coderxiao.com/2015/04/28/Tour-of-Computer-Systems-1/"/>
    <id>http://coderxiao.com/2015/04/28/Tour-of-Computer-Systems-1/</id>
    <published>2015-04-28T12:31:11.000Z</published>
    <updated>2015-04-28T13:26:34.000Z</updated>
    <content type="html"><![CDATA[<h2>从开机说起</h2>

<hr>
<p>当我们按下计算机的电源开关时候，计算机首先会自动从主板的<a href="http://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="external">BIOS</a>（基本输入输出系统）读取其中存储的程序。</p>
<p>它引导各个组件如内存、显卡开始运行，允许你从软盘、光盘或者硬盘中选择一个来启动计算机，之后将控制权移交给正常启动的主操作系统。</p>
<p>首先BIOS将从你所选择的存储设备中读取<code>起始的512bytes</code>(比如光盘一开始的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做<code>主引导记录MBR</code> (master boot record)。MBR会告诉电脑从该设备的<code>某一个分区</code>(partition)来装载<code>引导加载程序</code>(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有<code>GRUB</code>和<code>LILO</code>。</p>
<p>随后，boot loader会帮助我们<code>加载kernel</code>。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
<a id="more"></a>

<p>实际上，我们可以在<code>多个分区安装boot loader</code>，每个boot loader对应不同的操作系统，在读取MBR的时候选择我们想要启动的boot loader。这就是<code>多操作系统</code>的原理。</p>
<p>如果我们加载的是<code>Linux kernel</code>，Linux kernel开始工作。kernel会首先预留自己运行所需的内存空间，然后通过<code>驱动程序</code>(driver)检测计算机硬件。这样，操作系统就可以知道自己有哪些硬件可用。随后，kernel会启动一个<code>init进程</code>。它是Linux系统中的1号进程。到此，kernel就完成了在计算机启动阶段的工作，交接给init来管理。</p>
<p>随后，init会运行一系列的<code>初始脚本</code>(startup scripts)，这些脚本是Linux中常见的shell scripts。</p>
<p>这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等等。</p>
<p>当运行完这些初始脚本，操作系统已经完全准备好了，就等待用户进行登录操作。</p>
<h3>小结</h3>

<p>电源 -&gt; <strong>BIOS</strong> -&gt; <strong>MBR</strong> -&gt; <strong>boot loader</strong> -&gt; <strong>kernel</strong> -&gt; <strong>init process</strong> -&gt; <strong>login</strong></p>
<h2>追踪HelloWorld程序</h2>

<hr>
<p>好了，既然计算机已经打开了，我们就让它做点事情。</p>
<p>我们将通过追踪一个HelloWorld程序的生命周期来漫游计算机系统——从它被程序员创建，到系统上运行，以及输出简单的消息，然后终止。</p>
<p>下面是一个经典的HelloWorld程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hello.c</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>信息=位+上下文</h3><br>hello程序的生命周期是从一个源文件开始的，就是程序员利用编辑器创建并保存的文本文件，文件名字为hello.c。源程序实际上就是一个由值0和1组成的位序列，每8个位被组织成一组，称为字节。每个字节表示程序中的某一个字符。<br><br>大部分现代系统都使用<code>ASCII</code>标准来表示文本字符，这种方式实际上是用一个唯一的单字节大小的整数值（注意这个整数值其实就是由0和1的编码表示）来表示每个字符。<br><br>下面就是hello.c程序的ASCII码表示。<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloASCII.png" alt=""><br><br>像hello.c这样只由ASCII字符构成的文件称为<code>文本文件</code>，所有其他文件称为<code>二进制文件</code>。<br><br>hello.c的表示方法说明了一个基本的思想：<br><br><strong>计算机系统中所有信息——包括磁盘文件、存储器中的程序、存储器中存放的数据以及网络上传送的数据，都是由一串位来表示的。</strong><br><br>区分不同的数据对象的唯一方法是我们读到这些数据对象的<strong>上下文</strong>。比如，在不同的上下文中，一个同样的字节序列可能表示一个<code>整数、浮点数、字符串或者机器指令</code>。<br><br><h3>预处理、编译、汇编和链接</h3><br>为了可以在计算机上面运行hello.c程序，每一条C语句都必须被程序转换成一系列的<code>低级机器语言指令</code>。<br><br>然后这些指令按照一种称为可执行目标程序的格式打包好，并以二进制磁盘的文件的形式存放起来。<code>目标文件</code>也称为<code>可执行文件</code>。<br><br>在Linux上可以通过GCC编译器经过四个阶段得到可执行文件:<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloCompile.png" alt=""><br><br>1.<code>预处理</code>：处理#include，读取头文件stdio.h内容并将其插入到hello.c中，这样得到另一个程序hello.i。<br>    <strong>gcc -E hello.c  -&gt; hello.i</strong><br>2.<code>编译</code>：将hello.i翻译成汇编语言程序hello.s。<br>    <strong>gcc -S hello.i  -&gt; hello.s</strong><br>3.<code>汇编</code>：将hello.s翻译成机器语言指令，把这些指令打包成可重定位目标文件的格式，它的字节编码是机器语言指令而不是字符，所以打开hello.o将得到一堆乱码。<br>    <strong>gcc -c hello.s  -&gt; hello.o</strong><br>4.<code>链接</code>：hello程序调用了printf函数，printf函数存在于一个名字为printf.o的单独编译好的目标文件中，我们的程序必须将它合并到hello.o中，得到最终的可执行目标文件hello，它可以被加载到内存中，由系统执行。<br>    <strong>gcc -o hello.o  -&gt; hello</strong><br><br><h3>运行Hello World程序</h3><br>在得到的<code>hello</code>可执行文件同一目录下，我们在键盘中输入字符串<code>./hello</code>，shell程序将字符逐一读入寄存器，再把它放到存储器中，如下所示：<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun1.png" alt=""><br><br>当我们在键盘上面敲下回车时，shell程序就会知道我们已经结束了命令的输入，然后shell程序执行一系列的指令来加载hello可执行文件，并将hello中的代码和数据<code>从磁盘复制到主存中</code>。<br><br>一旦目标文件hello中的代码和数据被加载到内存，处理器就开始执行hello程序的main程序中的机器语言指令。<br><br>这些指令将<code>Hello World\n</code>字符串中的字节<code>从主存复制到寄存器文件</code>，再<code>从寄存器文件复制到显示设备</code>，最终显示在屏幕上。步骤如下：<br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun2.png" alt=""><br><br><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloRun3.png" alt=""><br><br><br><h3>高速缓存</h3>

<p>上面的展示揭露了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另外一个地方。</p>
<p>hello程序的机器指令从磁盘复制到主存，又从主存复制到处理器。而数据串<code>Hello World\n</code>则从磁盘复制到主存，又从主存复制到显示设备。</p>
<p>为了协调CPU和主存之间的差异和利用计算机的局部性原理，系统采用了更小更快的存储设备，即高速缓存存储器。如下所示：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloCache.png" alt=""></p>
<p>主要思想是<code>高一层的存储器作为低一层存储器的高速缓存</code>。在某些具有分布式文件系统的网络系统中，<code>本地磁盘就是存储在其他系统磁盘的数据的高速缓存</code>。</p>
<p><h3>操作系统提供的抽象</h3><br>抽象是计算机科学中最为重要的概念之一。</p>
<p>操作系统为我们提供了几个重要的抽象：</p>
<ol>
<li><code>文件</code>：文件是对IO设备的抽象。</li>
<li><code>进程</code>:对处理器、主存和IO设备的抽象。<strong>进程是程序的一次执行</strong>。</li>
<li><code>虚拟存储器</code>：对主存和磁盘IO设备的抽象。</li>
<li><code>虚拟机</code>：提供了对这个计算机（包括操作系统、处理器和程序）的抽象。</li>
</ol>
<h4>进程</h4>

<p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上面可以同时运行多个进程，而每个进程都好像是在独占地使用硬件。</p>
<p>一个CPU看上去都像在并发执行多个进程，这是<code>由于CPU在进程间快速切换实现</code>的。</p>
<p>操作系统保持追踪进程运行所需要的所有状态的信息。这种状态，也就是<strong>上下文</strong>，它包括许多信息，例如PC、寄存器信息等。</p>
<p>在任何一个时刻，单处理器系统只能执行一个程序的代码。</p>
<p>当操作系统决定要把控制权从当前进程转移到某一个新的进程的时候，就会发生上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后把控制权传递给新进程。</p>
<p>我们的shell程序作为A进程以及hello程序作为B进程，上下文切换如下所示：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloProess.png" alt=""></p>
<p>通常内核中会使用<code>进程表</code>来保存进程的上下文。</p>
<p>进程表中的内容如下：</p>
<ol>
<li><code>进程管理</code>相关：PC、寄存器、程序状态字、进程状态、优先级、调度参数、pid、ppid、pgid、信号、信号屏蔽字、CPU时间、启动时间等；</li>
<li><code>内存管理</code>相关：指向正文段的指针、指向数据段的指针、指向堆栈段的指针</li>
<li><code>文件管理</code>相关：根目录、工作目录、文件描述符表、用户ID、组ID</li>
</ol>
<h4>虚拟存储器</h4>

<p>在早期的计算机中，程序是直接运行在物理内存上的。换句话说，就是程序在运行的过程中访问的都是物理地址。</p>
<p>如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就一个程序，就这么点内存，用不用完那是程序自身的事情。</p>
<p>然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了，这个事情本身我们就称之为内存管理。</p>
<p>下面举一个早期的计算机系统中，内存分配管理的例子，以便于大家理解。</p>
<p>假如我们有三个程序，程序A、B、C。</p>
<p>程序A运行的过程中需要10M内存，程序B运行的过程中需要100M内存，而程序C运行的过程中需要20M内存。</p>
<p>如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A, 接下来的10M-110M分配给B。</p>
<p>现在假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。</p>
<p>大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。</p>
<p>下面我们来看看这种内存管理方式存在的几个比较明显的问题。</p>
<ol>
<li><code>进程地址空间不能隔离</code><br>由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃。这样很多恶意程序或者是木马程序可以轻而易举的破坏其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。</li>
<li><code>内存使用的效率低</code><br>如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。</li>
<li><code>程序运行的地址不能确定</code><br>程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址。</li>
</ol>
<p>那么怎么解决上面这三个问题呢？</p>
<p>有人说过：<strong>计算机系统里的任何问题都可以靠引入一个中间层来解决。</strong></p>
<p>现在的内存管理方法就是在程序和物理内存之间引入了虚拟内存这个概念。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义既然是虚拟地址，也就是虚的，不是现实存在的地址空间。</p>
<p>既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有<code>分段</code>和<code>分页</code>两种技术。</p>
<p><code>分段(Segmentation)</code>：这种方法是人们最开始使用的一种方法，基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个<br>物理地址空间。</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloSeg1.png" alt=""></p>
<p>每个程序都有其独立的进程地址空间，可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。</p>
<p>我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。</p>
<p>这种分段的机制<code>解决了</code>文章一开始提到的3个问题中的<code>进程地址空间隔离和程序地址重定位的问题</code>。</p>
<p>程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。</p>
<p>程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。</p>
<p>无论如何分段机制解决了上面两个问题，是一个很大的进步，但是对于内存效率问题仍然无能为力。因为这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。</p>
<p>那么，怎么才算高效率的内存使用呢?</p>
<p>事实上，根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。所以我们需要更加小粒度的内存分割和映射方法，另一种将虚拟地址转换为物理地址的方法分页机制应运而生了。</p>
<p><code>分页</code>：分页机制就是把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。</p>
<p>试想以下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果我想存储在磁盘上的文件是1K字节，那么其余的999K字节是不是浪费了。</p>
<p>Linux中一般页的大小是4KB，我们把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，如下图：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/helloSeg2.png" alt=""></p>
<p>我们可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内。</p>
<p>这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行。</p>
<p>甚至他们共用了一部分物理地址空间，这就是<code>共享内存</code>的概念了。</p>
<p>进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个<code>缺页异常</code>，然后异常管理程序会将其读到内存中。</p>
<p>分页机制的实现需要硬件的实现，这个硬件名字叫做<code>MMU(Memory Management Unit)</code>，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。</p>
<p>这个就是虚拟存储器的具体原理了。</p>
<h2>参考</h2>

<hr>
<p><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective</a>这是一本跨越编译原理、操作系统、计算机体系结构等多个学科的深入了解计算机系统的殿堂级著作。</p>
<p><a href="http://book.douban.com/subject/3652388/" target="_blank" rel="external">程序员的自我修养:链接、装载和库</a>程序员内功修炼。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>从开机说起</h2>

<hr>
<p>当我们按下计算机的电源开关时候，计算机首先会自动从主板的<a href="http://zh.wikipedia.org/wiki/BIOS" target="_blank" rel="external">BIOS</a>（基本输入输出系统）读取其中存储的程序。</p>
<p>它引导各个组件如内存、显卡开始运行，允许你从软盘、光盘或者硬盘中选择一个来启动计算机，之后将控制权移交给正常启动的主操作系统。</p>
<p>首先BIOS将从你所选择的存储设备中读取<code>起始的512bytes</code>(比如光盘一开始的512 bytes，如果我们从光盘启动的话)。这512 bytes叫做<code>主引导记录MBR</code> (master boot record)。MBR会告诉电脑从该设备的<code>某一个分区</code>(partition)来装载<code>引导加载程序</code>(boot loader)。Boot loader储存有操作系统(OS)的相关信息，比如操作系统名称，操作系统内核 (kernel)所在位置等。常用的boot loader有<code>GRUB</code>和<code>LILO</code>。</p>
<p>随后，boot loader会帮助我们<code>加载kernel</code>。kernel实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过kernel传达给硬件。Windows和Linux各自有自己kernel。狭义的操作系统就是指kernel，广义的操作系统包括kernel以及kernel之上的各种应用。</p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://coderxiao.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://coderxiao.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入了解单例模式]]></title>
    <link href="http://coderxiao.com/2015/04/19/Depth-in-Singleton/"/>
    <id>http://coderxiao.com/2015/04/19/Depth-in-Singleton/</id>
    <published>2015-04-19T11:12:41.000Z</published>
    <updated>2015-04-24T11:40:07.000Z</updated>
    <content type="html"><![CDATA[<h2>最简单的实现</h2>

<hr>
<p>在GoF的23种设计模式中，<code>单例模式</code>是比较简单的一种。</p>
<p>所谓的单例模式，就是在整个应用中保证只有一个类的实例存在。例如一些线程池和数据库连接池都要求是单实例的。</p>
<p>一种最简单的实现就是把类的构造函数写成<code>private</code>的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>如上面所示，外部使用者如果需要使用<code>SingletonClass</code>的实例，只能通过<code>getInstance()</code>方法，并且它的构造方法是<code>private</code>的，这样就保证了只能有一个对象存在。</p>
<h2>延迟加载</h2>

<hr>
<p>上面的代码虽然简单，但是存在一个问题，无论这个类是否被使用，都会创建一个<code>instance</code>对象。如果这个创建很耗时，比如需要连接10000次数据库，并且这个类还不一定被使用，那么这个创建过程就不是必须的。</p>
<p>为了解决这个问题，可以使用下面的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">			instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果要使用<code>instance</code>的话，第一次调用<code>getInstance()</code>发现<code>instance</code>是null，然后就创建一个新的对象并返回；第二次再调用的时候，因为这个<code>instance</code>已经不是null，因此不会再创建对象，直接将其返回。</p>
<p>这个过程就是<strong>延迟加载</strong>。</p>
<h2>同步</h2>

<hr>
<p>上面的代码在<code>单线程</code>中是可以正常运行的。但是在<code>多线程中</code>就麻烦了。</p>
<p>如果线程A在第一次调用<code>getInstance()</code>时判断<code>instance</code>是null的，于是它开始创建实例（创建）。</p>
<p>就在这时，CPU发生了时间片轮转，线程B开始执行，它调用<code>getInstance()</code>方法，同样检测到<code>instance</code>是null的，这时B开始创建对象，创建完后切换到A继续执行，这时A会继续创建对象。</p>
<p>这样线程A和线程B各自拥有一个SingletonClass的对象。<strong>单例创建失败</strong>。</p>
<p>解决的方法也很简单，只需加锁就可以了。但是由于性能应该<strong>使用更细粒度的同步块而非同步方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">synchronized</span> (SingletonClass.class) {</div><div class="line">			<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">				instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h2>又是性能</h2>

<hr>
<p>上面已经用同步块代替同步方法减少锁的粒度来提高性能。</p>
<p>但是这样的修改还是不起太大作用，因为每一次调用getInstance()的时候必然要同步，性能问题还是存在。</p>
<p>但是，如果我们事先判断一下是不是为null再去同步呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">			<span class="keyword">synchronized</span> (SingletonClass.class) {</div><div class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">					instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这就是<strong>double-checkd locking</strong>设计实现的单例模式。</p>
<h2>可见性</h2>

<hr>
<p>下面来想一下，创建一个变量需要哪些步骤呢？</p>
<p>一个是申请一块内存，调用构造方法进行初始化操作；另一个是分配一个指针指向这块内存。</p>
<p>这两个操作谁在前谁在后呢？JVM规范并没有规定。</p>
<p>那么就存在这么一种情况，JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。</p>
<p>下面对程序进行分析：线程A开始创建SingletonClass实例，此时线程B调用了getInstance方法，首先判断instance是否为空，按照上面所说的内存模型，A已经把instance指向了那块内存，只是还没有调用构造方法，此时B检测到instance不为空，于是直接返回instance了。</p>
<p>问题出现了，尽管instance不为null，但是它并没有构造完成，此时如果B在A将instance构造完成之前就调用了这个实例，程序就会出现错误。</p>
<p>于是，我们想到了volatile变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonClass instance = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">			<span class="keyword">synchronized</span> (SingletonClass.class) {</div><div class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>){</div><div class="line">					instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>然而，这个只是java5之后的解决方法，因为java5之后才支持volatile，其实还有另外一种方法不会受到Java版本的影响：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>{</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">return</span> SingletonClassInstance.instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个版本中，我们使用了Java的静态内部类。这种方式也是<code>Effiective Java</code>推荐的。</p>
<p>至此，我们提出了两种完好的解决方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>最简单的实现</h2>

<hr>
<p>在GoF的23种设计模式中，<code>单例模式</code>是比较简单的一种。</p>
<p>所谓的单例模式，就是在整个应用中保证只有一个类的实例存在。例如一些线程池和数据库连接池都要求是单实例的。</p>
<p>一种最简单的实现就是把类的构造函数写成<code>private</code>的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass instance = <span class="keyword">new</span> SingletonClass();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span>(){</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="title">SingletonClass</span>(){</div><div class="line">		</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Design Pattern" scheme="http://coderxiao.com/tags/Design-Pattern/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：线程带来的问题]]></title>
    <link href="http://coderxiao.com/2015/04/12/Thread-questions/"/>
    <id>http://coderxiao.com/2015/04/12/Thread-questions/</id>
    <published>2015-04-12T10:22:19.000Z</published>
    <updated>2015-04-24T10:29:10.000Z</updated>
    <content type="html"><![CDATA[<h2>安全性问题</h2>

<hr>
<p>毫无疑问，线性安全是很重要的。那么如何判断一个类是线性安全的呢？</p>
<p><strong>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调用代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为</strong>，那么就称这个类是线性安全的。</p>
<p>解决线程安全性问题可以用前面提到的加锁机制，包括类内置的锁和显式锁。</p>
<h2>活跃性问题</h2>

<hr>
<p><h3>死锁</h3><br>一个具体死锁的例子：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">		<span class="keyword">synchronized</span> (left) {</div><div class="line">			Thread.sleep(<span class="number">1000</span>);</div><div class="line">			<span class="keyword">synchronized</span> (right) {</div><div class="line">				System.out.println(<span class="string">"leftRight..."</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span>() <span class="keyword">throws</span> InterruptedException {</div><div class="line">		<span class="keyword">synchronized</span> (right) {</div><div class="line">			Thread.sleep(<span class="number">1000</span>);</div><div class="line">			<span class="keyword">synchronized</span> (left) {</div><div class="line">				System.out.println(<span class="string">"rightLeft..."</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		LeftRightDeadLock lr = <span class="keyword">new</span> LeftRightDeadLock();</div><div class="line">		<span class="keyword">new</span> AThread(lr).start();</div><div class="line">		<span class="keyword">new</span> BThread(lr).start();</div><div class="line">	}</div><div class="line">	</div><div class="line">}</div><div class="line"></div><div class="line">class AThread extends Thread{</div><div class="line">	<span class="keyword">private</span> LeftRightDeadLock lr;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">AThread</span>(LeftRightDeadLock lr) {</div><div class="line">		<span class="keyword">this</span>.lr = lr;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			lr.leftRight();</div><div class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">			e.printStackTrace();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class BThread extends Thread{</div><div class="line">	<span class="keyword">private</span> LeftRightDeadLock lr;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BThread</span>(LeftRightDeadLock lr) {</div><div class="line">		<span class="keyword">this</span>.lr = lr;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			lr.rightLeft();</div><div class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">			e.printStackTrace();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行时候将什么也没有输出，因为两个线程都在等待对方释放锁。</p>
<p>通常解决的方法有下面两种：</p>
<ol>
<li><code>按照顺序加锁</code>：例如将上面的加锁顺序改为都是先对right加锁，然后才对left加锁。</li>
<li><code>使用定时锁，避免进入无限循环</code>。例如可以显式使用Lock类中的定时tryLock功能来代替内置锁机制。</li>
</ol>
<p><h3>饥饿</h3><br>当线程由于无法访问它所需要的资源而不能继续执行时，就发生<code>饥饿</code>。</p>
<p>引发饥饿的最常见的资源就是CPU的时钟周期。如果在Java程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的方法（例如无限循环），那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。</p>
<p>通常，我们尽量不要改变线程的优先级，因为改变了优先级，程序的行为将和平台有关，并且会导致发生饥饿问题的风险。</p>
<p><h3>活锁</h3><br>活锁是另外一种形式的活跃性问题。该问题虽然不会阻塞线程，但是也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。</p>
<p>当多个相互协作的线程对于彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。这就像两个过于礼貌的人在半路上相遇，他们彼此都让出了对方的路，然而又在另外一条路上遇上了。因此他们就这样反复地避让下去。</p>
<p>要解决这种活锁问题，需要在重试机制中引入随机性。通过等待随机长度的时间和回退可以有效地避免活锁的产生。</p>
<h2>性能问题</h2>

<hr>
<p>线程的最主要的目的是提高程序的运行性能。</p>
<p>尽管使用多个线程的目标是提升整体性能，但与单线程的方法相比，使用多个线程总会引入一些额外的性能开销。</p>
<p>造成这些开销的操作包括：线程之间的协调（例如加锁、触发信号以及内存同步）、增加的上下文切换、线程的创建和销毁、以及线程的调度等。</p>
<p>通常为了减少这些开销，提高整体的吞吐量和伸缩性，可以通过下面的方法：</p>
<ol>
<li><code>减少锁的持有时间</code>。</li>
<li><code>降低锁的粒度</code>：例如可以使用同步块代替同步方法，或者使用显式锁来代替内置锁。</li>
<li><code>使用非独占的锁或者非阻塞的锁来代替锁</code>：例如并发容器、volatile变量、原子变量等。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2>安全性问题</h2>

<hr>
<p>毫无疑问，线性安全是很重要的。那么如何判断一个类是线性安全的呢？</p>
<p><strong>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调用代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为</strong>，那么就称这个类是线性安全的。</p>
<p>解决线程安全性问题可以用前面提到的加锁机制，包括类内置的锁和显式锁。</p>
<h2>活跃性问题</h2>

<hr>
<p><h3>死锁</h3><br>一个具体死锁的例子：</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—同步工具]]></title>
    <link href="http://coderxiao.com/2015/04/09/Thread-synchronize-tools/"/>
    <id>http://coderxiao.com/2015/04/09/Thread-synchronize-tools/</id>
    <published>2015-04-09T10:45:12.000Z</published>
    <updated>2015-04-23T14:36:29.000Z</updated>
    <content type="html"><![CDATA[<h2>CountDownLatch</h2>

<hr>
<p>CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p>CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。</p>
<p>假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的<code>await()</code>方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的<code>countDown()</code>方法，这个调用<code>await()</code>方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">CountDownLatch</span>(<span class="keyword">int</span> count);</div><div class="line">	构造方法，指定了计数的次数</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span>();</div><div class="line">	当前线程调用此方法，则计数减一</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>();</div><div class="line">	调用此方法会一直阻塞当前线程，直到计时器的值为<span class="number">0</span></div></pre></td></tr></table></figure>

<a id="more"></a>

<h3>例子</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="javadoc">/***</span></div><div class="line"> * CountDownLatch</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{ </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {  </div><div class="line">        CountDownLatch latch=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);<span class="comment">//两个工人的协作  </span></div><div class="line">        Worker worker1=<span class="keyword">new</span> Worker(<span class="string">"A"</span>, latch);  </div><div class="line">        Worker worker2=<span class="keyword">new</span> Worker(<span class="string">"B"</span>, latch);  </div><div class="line">        worker1.start();<span class="comment">//  </span></div><div class="line">        worker2.start();<span class="comment">//  </span></div><div class="line">        latch.await();<span class="comment">//等待所有工人完成工作  </span></div><div class="line">        System.out.println(<span class="string">"吃饭去..."</span>);</div><div class="line">    }   </div><div class="line">} </div><div class="line"></div><div class="line"></div><div class="line">class Worker extends Thread{  </div><div class="line">    String workerName;   </div><div class="line">    CountDownLatch latch;  </div><div class="line">    <span class="keyword">public</span> <span class="title">Worker</span>(String workerName ,CountDownLatch latch){  </div><div class="line">         <span class="keyword">this</span>.workerName=workerName;  </div><div class="line">         <span class="keyword">this</span>.latch=latch;  </div><div class="line">    }  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){  </div><div class="line">        System.out.println(<span class="string">"Worker "</span>+workerName+<span class="string">" finish work "</span>);  </div><div class="line">        <span class="keyword">try</span> {</div><div class="line">			Thread.sleep(<span class="number">2000</span>);</div><div class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">			e.printStackTrace();</div><div class="line">		}</div><div class="line">        latch.countDown();<span class="comment">//工人完成工作，计数器减一  </span></div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Worker A finish work </div><div class="line">Worker B finish work </div><div class="line">吃饭去...</div></pre></td></tr></table></figure>

<h2>CyclicBarrier</h2>

<hr>
<p>CyclicBarrier和CountDownLatch差不多,也可以用于只有当所有子任务都执行完成时候，才能执行主任务的情况。</p>
<h3>例子</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="javadoc">/** </span></div><div class="line">* CyclicBarrier</div><div class="line">* </div><div class="line">*/ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{ </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { </div><div class="line">                <span class="comment">//创建障碍器，并设置MainTask为所有定数量的线程都达到障碍点时候所要执行的任务</span></div><div class="line">                CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, <span class="keyword">new</span> MainTask()); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"A"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"B"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"C"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"D"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"E"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"F"</span>, cb).start(); </div><div class="line">                <span class="keyword">new</span> SubTask(<span class="string">"G"</span>, cb).start(); </div><div class="line">        } </div><div class="line">} </div><div class="line"></div><div class="line"><span class="javadoc">/** </span></div><div class="line">* 主任务 </div><div class="line">*/ </div><div class="line">class MainTask implements Runnable { </div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() { </div><div class="line">                System.out.println(<span class="string">"主任务执行了..."</span>); </div><div class="line">        } </div><div class="line">} </div><div class="line"></div><div class="line"><span class="javadoc">/** </span></div><div class="line">* 子任务 </div><div class="line">*/ </div><div class="line">class SubTask extends Thread { </div><div class="line">        <span class="keyword">private</span> String name; </div><div class="line">        <span class="keyword">private</span> CyclicBarrier cb; </div><div class="line"></div><div class="line">        SubTask(String name, CyclicBarrier cb) { </div><div class="line">                <span class="keyword">this</span>.name = name; </div><div class="line">                <span class="keyword">this</span>.cb = cb; </div><div class="line">        } </div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() { </div><div class="line">                System.out.println(<span class="string">"[子任务"</span> + name + <span class="string">"]开始执行了"</span>); </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++) ;    <span class="comment">//模拟耗时的任务 </span></div><div class="line">                System.out.println(<span class="string">"[子任务"</span> + name + <span class="string">"]开始执行完成了，并通知障碍器已经完成"</span>); </div><div class="line">                <span class="keyword">try</span> { </div><div class="line">                        <span class="comment">//通知障碍器已经完成 </span></div><div class="line">                        cb.await(); </div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) { </div><div class="line">                        e.printStackTrace(); </div><div class="line">                } <span class="keyword">catch</span> (BrokenBarrierException e) { </div><div class="line">                        e.printStackTrace(); </div><div class="line">                } </div><div class="line">        } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[子任务B]开始执行了</div><div class="line">[子任务D]开始执行了</div><div class="line">[子任务A]开始执行了</div><div class="line">[子任务E]开始执行了</div><div class="line">[子任务C]开始执行了</div><div class="line">[子任务A]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务D]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务C]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务F]开始执行了</div><div class="line">[子任务B]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务E]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务G]开始执行了</div><div class="line">[子任务F]开始执行完成了，并通知障碍器已经完成</div><div class="line">[子任务G]开始执行完成了，并通知障碍器已经完成</div><div class="line">主任务执行了...</div></pre></td></tr></table></figure>

<h2>总结</h2>

<hr>
<p><code>CountDownLatch</code>是所有子程序执行完以后，再执行主线程。<strong>关注的是主线程。</strong><br><code>CyclicBarrier</code>是所有子线程都执行到某一点后，再继续执行。<strong>关注的是子线程.</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>CountDownLatch</h2>

<hr>
<p>CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</p>
<p>CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。</p>
<p>假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的<code>await()</code>方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的<code>countDown()</code>方法，这个调用<code>await()</code>方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">CountDownLatch</span>(<span class="keyword">int</span> count);</div><div class="line">	构造方法，指定了计数的次数</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span>();</div><div class="line">	当前线程调用此方法，则计数减一</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span>();</div><div class="line">	调用此方法会一直阻塞当前线程，直到计时器的值为<span class="number">0</span></div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—有返回值的线程]]></title>
    <link href="http://coderxiao.com/2015/04/08/Thread-threadReturn/"/>
    <id>http://coderxiao.com/2015/04/08/Thread-threadReturn/</id>
    <published>2015-04-08T12:15:26.000Z</published>
    <updated>2015-04-23T13:56:00.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>Java5增加了有返回值的线程。可返回值的任务（线程）必须实现<code>Callable</code>接口，类似的，无返回值的任务（线程）必须<code>Runnable</code>接口。</p>
<p>执行<code>Callable</code>任务后，可以获取一个<code>Future</code>的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。</p>
<h2>例子</h2>

<hr>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"></div><div class="line"><span class="javadoc">/** </span></div><div class="line">* 有返回值的线程 </div><div class="line">* </div><div class="line">*/ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{ </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> ExecutionException, InterruptedException { </div><div class="line">                <span class="comment">//创建一个线程池 </span></div><div class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </div><div class="line">                <span class="comment">//创建两个有返回值的任务 </span></div><div class="line">                Callable c1 = <span class="keyword">new</span> MyCallable(<span class="string">"A"</span>); </div><div class="line">                Callable c2 = <span class="keyword">new</span> MyCallable(<span class="string">"B"</span>); </div><div class="line">                <span class="comment">//执行任务并获取Future对象 </span></div><div class="line">                Future f1 = pool.submit(c1); </div><div class="line">                Future f2 = pool.submit(c2); </div><div class="line">                <span class="comment">//从Future对象上获取任务的返回值，并输出到控制台 </span></div><div class="line">                System.out.println(<span class="string">"--&gt;"</span>+f1.get().toString()); </div><div class="line">                System.out.println(<span class="string">"--&gt;"</span>+f2.get().toString()); </div><div class="line">                <span class="comment">//关闭线程池 </span></div><div class="line">                pool.shutdown(); </div><div class="line">        } </div><div class="line">} </div><div class="line"></div><div class="line"></div><div class="line">class MyCallable implements Callable{ </div><div class="line">        <span class="keyword">private</span> String oid; </div><div class="line"></div><div class="line">        MyCallable(String oid) { </div><div class="line">                <span class="keyword">this</span>.oid = oid; </div><div class="line">        } </div><div class="line"></div><div class="line">        <span class="annotation">@Override</span> </div><div class="line">        <span class="keyword">public</span> Object <span class="title">call</span>() <span class="keyword">throws</span> Exception { </div><div class="line">                <span class="keyword">return</span> oid+<span class="string">"任务返回的内容"</span>; </div><div class="line">        } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">--&gt;A任务返回的内容</div><div class="line">--&gt;B任务返回的内容</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>Java5增加了有返回值的线程。可返回值的任务（线程）必须实现<code>Callable</code>接口，类似的，无返回值的任务（线程）必须<code>Runnable</code>接口。</p>
<p>执行<code>Callable</code>任务后，可以获取一个<code>Future</code>的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。</p>
<h2>例子</h2>

<hr>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—线程池]]></title>
    <link href="http://coderxiao.com/2015/04/08/Thread-threadPool/"/>
    <id>http://coderxiao.com/2015/04/08/Thread-threadPool/</id>
    <published>2015-04-08T10:32:15.000Z</published>
    <updated>2015-04-23T13:55:28.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。</p>
<p>当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<p>Java5的线程池分好多种：<code>固定尺寸的线程池</code>、<code>可变尺寸连接池</code>、当然你还可以<code>自定义线程池</code>。</p>
<p>在使用线程池之前，必须知道如何去创建一个线程池，在Java5中，需要了解的是<code>java.util.concurrent.Executors</code>类的API，这个类提供大量创建连接池的静态方法，是必须掌握的。</p>
<h2>固定大小的线程池</h2>

<hr>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="javadoc">/** </span></div><div class="line">* 固定大小的线程池</div><div class="line">* </div><div class="line">*/ </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{ </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) { </div><div class="line">                <span class="comment">//创建一个可重用固定线程数的线程池 </span></div><div class="line">                ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>); </div><div class="line">                <span class="comment">//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 </span></div><div class="line">                Thread t1 = <span class="keyword">new</span> MyThread(); </div><div class="line">                Thread t2 = <span class="keyword">new</span> MyThread(); </div><div class="line">                Thread t3 = <span class="keyword">new</span> MyThread(); </div><div class="line">                Thread t4 = <span class="keyword">new</span> MyThread(); </div><div class="line">                Thread t5 = <span class="keyword">new</span> MyThread(); </div><div class="line">                <span class="comment">//将线程放入池中进行执行 </span></div><div class="line">                pool.execute(t1); </div><div class="line">                pool.execute(t2); </div><div class="line">                pool.execute(t3); </div><div class="line">                pool.execute(t4); </div><div class="line">                pool.execute(t5); </div><div class="line">                <span class="comment">//关闭线程池 </span></div><div class="line">                pool.shutdown(); </div><div class="line">        } </div><div class="line">} </div><div class="line"></div><div class="line">class MyThread extends Thread{ </div><div class="line">        <span class="annotation">@Override</span> </div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() { </div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行..."</span>); </div><div class="line">        } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div></pre></td></tr></table></figure>

<h2>单任务线程池</h2>

<hr>
<p>在上面的代码中只需修改创建pool对象的那行代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。 </span></div><div class="line">ExecutorService pool = Executors.newSingleThreadExecutor();</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div></pre></td></tr></table></figure>

<h2>可变尺寸的线程池</h2>

<hr>
<p>在上面的代码中只需修改创建pool对象的那行代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。 </span></div><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>正在执行...</div><div class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>正在执行...</div></pre></td></tr></table></figure>

<h2>自定义线程池</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="javadoc">/***</span></div><div class="line"> * 用显式锁和条件变量实现的可计数的线性池</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountableThreadPool</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threadNum;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> AtomicInteger threadAlive = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Condition condition = reentrantLock.newCondition();</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">CountableThreadPool</span>(<span class="keyword">int</span> threadNum) {</div><div class="line">		<span class="keyword">this</span>.threadNum = threadNum;</div><div class="line">		<span class="keyword">this</span>.executorService = Executors.newFixedThreadPool(threadNum);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">CountableThreadPool</span>(<span class="keyword">int</span> threadNum, ExecutorService executorService) {</div><div class="line">		<span class="keyword">this</span>.threadNum = threadNum;</div><div class="line">		<span class="keyword">this</span>.executorService = executorService;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorService</span>(ExecutorService executorService) {</div><div class="line">		<span class="keyword">this</span>.executorService = executorService;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadAlive</span>() {</div><div class="line">		<span class="keyword">return</span> threadAlive.get();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadNum</span>() {</div><div class="line">		<span class="keyword">return</span> threadNum;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ExecutorService executorService;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="keyword">final</span> Runnable runnable) {</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (threadAlive.get() &gt;= threadNum) {</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				reentrantLock.lock();</div><div class="line">				<span class="keyword">while</span> (threadAlive.get() &gt;= threadNum) {</div><div class="line">					<span class="keyword">try</span> {</div><div class="line">						condition.await();</div><div class="line">					} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">					}</div><div class="line">				}</div><div class="line">			} <span class="keyword">finally</span> {</div><div class="line">				reentrantLock.unlock();</div><div class="line">			}</div><div class="line">		}</div><div class="line">		threadAlive.incrementAndGet();</div><div class="line">		executorService.execute(<span class="keyword">new</span> Runnable() {</div><div class="line">			<span class="annotation">@Override</span></div><div class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">				<span class="keyword">try</span> {</div><div class="line">					runnable.run();</div><div class="line">				} <span class="keyword">finally</span> {</div><div class="line">					<span class="keyword">try</span> {</div><div class="line">						reentrantLock.lock();</div><div class="line">						threadAlive.decrementAndGet();</div><div class="line">						condition.signal();</div><div class="line">					} <span class="keyword">finally</span> {</div><div class="line">						reentrantLock.unlock();</div><div class="line">					}</div><div class="line">				}</div><div class="line">			}</div><div class="line">		});</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span>() {</div><div class="line">		<span class="keyword">return</span> executorService.isShutdown();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span>() {</div><div class="line">		executorService.shutdown();</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。</p>
<p>当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p>
<p>Java5的线程池分好多种：<code>固定尺寸的线程池</code>、<code>可变尺寸连接池</code>、当然你还可以<code>自定义线程池</code>。</p>
<p>在使用线程池之前，必须知道如何去创建一个线程池，在Java5中，需要了解的是<code>java.util.concurrent.Executors</code>类的API，这个类提供大量创建连接池的静态方法，是必须掌握的。</p>
<h2>固定大小的线程池</h2>

<hr>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—原子变量和CAS]]></title>
    <link href="http://coderxiao.com/2015/04/05/Thread-atomic-cas/"/>
    <id>http://coderxiao.com/2015/04/05/Thread-atomic-cas/</id>
    <published>2015-04-05T10:21:26.000Z</published>
    <updated>2015-04-23T13:56:46.000Z</updated>
    <content type="html"><![CDATA[<h2>硬件对并发的支持</h2>

<hr>
<p>现在，几乎所有的现代处理器中都包含了某种形式的<strong>原子读-改-写指令</strong>，例如比较和交换（<code>CAS</code>）或者关联加载和条件存储（<code>Load-Linked/Store-Conditional</code>）。</p>
<p>操作系统和JVM可以使用这些指令来实现锁和并发的数据结构。例如Java的<code>ConcurrentlinkedQueue</code>就是使用CAS实现的。</p>
<p>Java5以后也提供了对这些指令的支持。当多个线程尝试使用CAS同时更新同一个变量时候，只有一个线程能更新变量的值，而其他线程都将失败。</p>
<p>然而，失败的线程并不会被挂起（这与获取锁的情况不同：当获取锁失败时，线程将会被挂起），而是被告知在这次竞争中失败，并且可以重试。</p>
<p><strong>由于一个线程在竞争CAS时失败不会被阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何操作。</strong></p>
<a id="more"></a>

<p>这种灵活性就大大减少了与锁相关的活跃性风险。</p>
<p>实际上，当竞争程度不高时，基于CAS的计数器在性能上远远高于基于锁的计数器，而在没有竞争时候甚至更加高。</p>
<p>CAS的<strong>主要缺点</strong>是：它将使调用者处理竞争问题（通过重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞）。也可能产生<code>ABA</code>问题。</p>
<h2>锁的劣势</h2>

<hr>
<p>若使用锁机制，当多个线程同时请求锁，那么JVM就需要借助操作系统的功能。</p>
<p>那么一些线程将会被挂起并且在稍后恢复运行。当线程恢复执行时，必须等待其他线程执行完它们的时间片以后，才能被调度执行。</p>
<p>在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。</p>
<p>与锁相比，<code>volatile</code>变量是一种更加轻量级的同步机制，因为在使用这些变量时候不会发生上下文切换或者线程调度等操作。</p>
<p>Java5之后，专门提供了用来进行单变量多线程并发安全访问的工具包<code>java.util.concurrent.atomic</code>，称为原子变量类。</p>
<p>原子变量类直接利用了硬件对并发的支持，采用CAS算法提供了更高的可伸缩性。</p>
<h2>例子</h2>

<hr>
<p>使用原子变量不再需要对变量加锁，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span>() {</div><div class="line">		 count.incrementAndGet();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line"></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>硬件对并发的支持</h2>

<hr>
<p>现在，几乎所有的现代处理器中都包含了某种形式的<strong>原子读-改-写指令</strong>，例如比较和交换（<code>CAS</code>）或者关联加载和条件存储（<code>Load-Linked/Store-Conditional</code>）。</p>
<p>操作系统和JVM可以使用这些指令来实现锁和并发的数据结构。例如Java的<code>ConcurrentlinkedQueue</code>就是使用CAS实现的。</p>
<p>Java5以后也提供了对这些指令的支持。当多个线程尝试使用CAS同时更新同一个变量时候，只有一个线程能更新变量的值，而其他线程都将失败。</p>
<p>然而，失败的线程并不会被挂起（这与获取锁的情况不同：当获取锁失败时，线程将会被挂起），而是被告知在这次竞争中失败，并且可以重试。</p>
<p><strong>由于一个线程在竞争CAS时失败不会被阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何操作。</strong></p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—同步容器]]></title>
    <link href="http://coderxiao.com/2015/04/02/Thread-concurrency/"/>
    <id>http://coderxiao.com/2015/04/02/Thread-concurrency/</id>
    <published>2015-04-02T10:13:16.000Z</published>
    <updated>2015-04-20T14:30:17.000Z</updated>
    <content type="html"><![CDATA[<h2>阻塞队列</h2>

<hr>
<p>阻塞队列是Java5线程新特性中的内容，Java定义了阻塞队列的接口<code>java.util.concurrent.BlockingQueue</code>。</p>
<p>阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。</p>
<p>同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。</p>
<p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 阻塞队列</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line">		BlockingQueue bqueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</div><div class="line">			<span class="comment">// 将指定元素添加到此队列中，如果没有可用空间，将一直等待（如果有必要）。</span></div><div class="line">			bqueue.put(i);</div><div class="line">			System.out.println(<span class="string">"add to queue: "</span> + i);</div><div class="line">		}</div><div class="line">		System.out.println(<span class="string">"over..."</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">add to queue: <span class="number">0</span></div><div class="line">add to queue: <span class="number">1</span></div><div class="line">add to queue: <span class="number">2</span></div><div class="line">add to queue: <span class="number">3</span></div><div class="line">add to queue: <span class="number">4</span></div><div class="line">add to queue: <span class="number">5</span></div><div class="line">add to queue: <span class="number">6</span></div><div class="line">add to queue: <span class="number">7</span></div><div class="line">add to queue: <span class="number">8</span></div><div class="line">add to queue: <span class="number">9</span></div></pre></td></tr></table></figure>

<p>可以看出，输出到元素9时候，就一直处于等待状态，因为队列满了，程序阻塞了。</p>
<p>阻塞队列还有更多实现类，用来满足各种复杂的需求：<br><code>ArrayBlockingQueue</code>, <code>DelayQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>SynchronousQueue</code>，具体的API差别也很小。</p>
<h2>阻塞栈</h2>

<hr>
<p>阻塞栈是Java6的新特性,对于阻塞栈，与阻塞队列相似。不同点在于<code>栈是“后入先出”</code>的结构，每次操作的是栈顶，而<code>队列是“先进先出”</code>的结构，每次操作的是队列头。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 阻塞栈</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line">		BlockingDeque bDeque = <span class="keyword">new</span> LinkedBlockingDeque(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</div><div class="line">			<span class="comment">// 将指定元素添加到此阻塞栈中，如果没有可用空间，将一直等待（如果有必要）。</span></div><div class="line">			bDeque.putFirst(i);</div><div class="line">			System.out.println(<span class="string">"add to stack: "</span> + i);</div><div class="line">		}</div><div class="line">		System.out.println(<span class="string">"over..."</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">add to stack: <span class="number">0</span></div><div class="line">add to stack: <span class="number">1</span></div><div class="line">add to stack: <span class="number">2</span></div><div class="line">add to stack: <span class="number">3</span></div><div class="line">add to stack: <span class="number">4</span></div><div class="line">add to stack: <span class="number">5</span></div><div class="line">add to stack: <span class="number">6</span></div><div class="line">add to stack: <span class="number">7</span></div><div class="line">add to stack: <span class="number">8</span></div><div class="line">add to stack: <span class="number">9</span></div></pre></td></tr></table></figure>

<p>可以看出，输出到元素9时候，就一直处于等待状态，因为栈满了，程序阻塞了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>阻塞队列</h2>

<hr>
<p>阻塞队列是Java5线程新特性中的内容，Java定义了阻塞队列的接口<code>java.util.concurrent.BlockingQueue</code>。</p>
<p>阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。</p>
<p>同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。</p>
<p>有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 阻塞队列</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line">		BlockingQueue bqueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</div><div class="line">			<span class="comment">// 将指定元素添加到此队列中，如果没有可用空间，将一直等待（如果有必要）。</span></div><div class="line">			bqueue.put(i);</div><div class="line">			System.out.println(<span class="string">"add to queue: "</span> + i);</div><div class="line">		}</div><div class="line">		System.out.println(<span class="string">"over..."</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—信号量]]></title>
    <link href="http://coderxiao.com/2015/03/26/Thread-semaphore/"/>
    <id>http://coderxiao.com/2015/03/26/Thread-semaphore/</id>
    <published>2015-03-26T02:02:56.000Z</published>
    <updated>2015-04-20T14:32:09.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>Java的信号量实际上是一个<code>功能完毕的计数器</code>，对控制一定资源的消费与回收有着很重要的意义。</p>
<p>信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等。</p>
<p>这里总是在强调<code>“数目”</code>二字，但不能指出来有哪些在等待，哪些资源可用。</p>
<h2>例子</h2>

<a id="more"></a>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 信号量测试</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		MyPool myPool = <span class="keyword">new</span> MyPool(<span class="number">20</span>);</div><div class="line">		<span class="comment">// 创建线程池</span></div><div class="line">		ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">		MyT t1 = <span class="keyword">new</span> MyT(<span class="string">"任务A"</span>, myPool, <span class="number">3</span>);</div><div class="line">		MyT t2 = <span class="keyword">new</span> MyT(<span class="string">"任务B"</span>, myPool, <span class="number">12</span>);</div><div class="line">		MyT t3 = <span class="keyword">new</span> MyT(<span class="string">"任务C"</span>, myPool, <span class="number">7</span>);</div><div class="line">		<span class="comment">// 在线程池中执行任务</span></div><div class="line">		threadPool.execute(t1);</div><div class="line">		threadPool.execute(t2);</div><div class="line">		threadPool.execute(t3);</div><div class="line">		<span class="comment">// 关闭池</span></div><div class="line">		threadPool.shutdown();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 一个池</div><div class="line"> */</div><div class="line">class MyPool {</div><div class="line">	<span class="keyword">private</span> Semaphore sp; <span class="comment">// 池相关的信号量</span></div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 池的大小，这个大小会传递给信号量</div><div class="line">	 * </div><div class="line">	 *<span class="javadoctag"> @param</span> size</div><div class="line">	 *            池的大小</div><div class="line">	 */</div><div class="line">	MyPool(<span class="keyword">int</span> size) {</div><div class="line">		<span class="keyword">this</span>.sp = <span class="keyword">new</span> Semaphore(size);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Semaphore <span class="title">getSp</span>() {</div><div class="line">		<span class="keyword">return</span> sp;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSp</span>(Semaphore sp) {</div><div class="line">		<span class="keyword">this</span>.sp = sp;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyT extends Thread {</div><div class="line">	<span class="keyword">private</span> String threadname; <span class="comment">// 线程的名称</span></div><div class="line">	<span class="keyword">private</span> MyPool pool; <span class="comment">// 自定义池</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// 申请信号量的大小</span></div><div class="line"></div><div class="line">	MyT(String threadname, MyPool pool, <span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">this</span>.threadname = threadname;</div><div class="line">		<span class="keyword">this</span>.pool = pool;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			<span class="comment">// 从此信号量获取给定数目的许可</span></div><div class="line">			pool.getSp().acquire(x);</div><div class="line">			<span class="comment">// todo：也许这里可以做更复杂的业务</span></div><div class="line">			System.out.println(threadname + <span class="string">"成功获取了"</span> + x + <span class="string">"个许可！"</span>);</div><div class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">			e.printStackTrace();</div><div class="line">		} <span class="keyword">finally</span> {</div><div class="line">			<span class="comment">// 释放给定数目的许可，将其返回到信号量。</span></div><div class="line">			pool.getSp().release(x);</div><div class="line">			System.out.println(threadname + <span class="string">"释放了"</span> + x + <span class="string">"个许可！"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">任务A成功获取了<span class="number">3</span>个许可！</div><div class="line">任务B成功获取了<span class="number">12</span>个许可！</div><div class="line">任务B释放了<span class="number">12</span>个许可！</div><div class="line">任务C成功获取了<span class="number">7</span>个许可！</div><div class="line">任务C释放了<span class="number">7</span>个许可！</div><div class="line">任务A释放了<span class="number">3</span>个许可！</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>Java的信号量实际上是一个<code>功能完毕的计数器</code>，对控制一定资源的消费与回收有着很重要的意义。</p>
<p>信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等。</p>
<p>这里总是在强调<code>“数目”</code>二字，但不能指出来有哪些在等待，哪些资源可用。</p>
<h2>例子</h2>

]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：新特性—显式锁和条件变量]]></title>
    <link href="http://coderxiao.com/2015/03/24/Thread-condition-lock/"/>
    <id>http://coderxiao.com/2015/03/24/Thread-condition-lock/</id>
    <published>2015-03-24T10:45:19.000Z</published>
    <updated>2015-04-20T14:03:56.000Z</updated>
    <content type="html"><![CDATA[<h2>显式锁</h2>

<hr>
<p>在Java5.0之前，在协调共享对象的访问时候可以使用的机制只有synchronized和volatile。</p>
<p>Java5.0增加了一种新的机制：ReentrantLock。称为显式锁，相对于对象的内置锁而言。</p>
<p>这个专门提供的锁对象，可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制。</p>
<p>这些内容主要集中在<code>java.util.concurrent.locks</code>包下面，里面有三个重要的接口:<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Condition</div><div class="line">	Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待set（wait-set）。</div><div class="line">Lock</div><div class="line">	Lock 实现提供了比使用 <span class="keyword">synchronized</span> 方法和语句可获得的更广泛的锁定操作。</div><div class="line">ReadWriteLock</div><div class="line">	ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。</div></pre></td></tr></table></figure>

<a id="more"></a>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/***</span></div><div class="line"> * 显式锁测试</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Lock lock;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">LockTest</span>(Lock lock) {</div><div class="line">		<span class="keyword">this</span>.lock = lock;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		lock.lock();</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++){</div><div class="line">				System.out.println(Thread.currentThread().getName());</div><div class="line">				Thread.sleep(<span class="number">1000</span>);</div><div class="line">			}</div><div class="line">		}<span class="keyword">catch</span>(Exception e){</div><div class="line">			</div><div class="line">		}<span class="keyword">finally</span>{</div><div class="line">			lock.unlock();</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">		LockTest[] array = <span class="keyword">new</span> LockTest[<span class="number">2</span>];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {</div><div class="line">			array[i] = <span class="keyword">new</span> LockTest(lock);</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {</div><div class="line">			array[i].start();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">0</span></div><div class="line">Thread-<span class="number">1</span></div><div class="line">Thread-<span class="number">1</span></div></pre></td></tr></table></figure>

<p>从上面的输出可以看到，利用锁对象太方便了，比直接在某个不知情的对象上用锁清晰多了。</p>
<p>但一定要注意的是，在获取了锁对象后，<strong>用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行</strong>。</p>
<p>为了可以释放锁，经典写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span>{</div><div class="line">	</div><div class="line">}<span class="keyword">catch</span>(Exception e){</div><div class="line">	</div><div class="line">}<span class="keyword">finally</span>{</div><div class="line">	lock.unlock();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，Java提供了读写锁<code>ReadWriteLock</code>，在读的地方使用读锁(<em>可以多个线程访问</em>)，在写的地方使用写锁(<em>只有一个线程访问</em>)，灵活控制，在一定程度上可以提高程序的执行效率。</p>
<p><strong>在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</strong></p>
<h2>条件变量</h2>

<hr>
<p>条件变量是Java5.0线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</p>
<p>条件变量都实现了<code>java.util.concurrent.locks.Condition</code>接口，条件变量的实例化是通过一个<code>Lock</code>对象上调用<code>newCondition()</code>方法来获取的，这样，条件就和一个锁对象绑定起来了。</p>
<p>因此，<strong>Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全</strong>。</p>
<p>条件变量的出现是为了更精细控制线程等待与唤醒，在Java5.0之前，线程的等待与唤醒依靠的是Object对象的<code>wait()</code>和<code>notify()/notifyAll()</code>方法，这样的处理不够精细。</p>
<p>注意：<strong>这两套机制不能混合使用，这是两套独立的机制。</strong></p>
<p>而在Java5.0中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。</p>
<p>当调用signalAll()方法，又可以唤醒该条件下的等待的线程。有关Condition接口的API可以具体参考JavaAPI文档。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>显式锁</h2>

<hr>
<p>在Java5.0之前，在协调共享对象的访问时候可以使用的机制只有synchronized和volatile。</p>
<p>Java5.0增加了一种新的机制：ReentrantLock。称为显式锁，相对于对象的内置锁而言。</p>
<p>这个专门提供的锁对象，可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制。</p>
<p>这些内容主要集中在<code>java.util.concurrent.locks</code>包下面，里面有三个重要的接口:<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Condition</div><div class="line">	Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待set（wait-set）。</div><div class="line">Lock</div><div class="line">	Lock 实现提供了比使用 <span class="keyword">synchronized</span> 方法和语句可获得的更广泛的锁定操作。</div><div class="line">ReadWriteLock</div><div class="line">	ReadWriteLock 维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：volatile变量]]></title>
    <link href="http://coderxiao.com/2015/03/17/Thread-volatile/"/>
    <id>http://coderxiao.com/2015/03/17/Thread-volatile/</id>
    <published>2015-03-17T07:06:41.000Z</published>
    <updated>2015-04-20T12:53:04.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>Java语言提供了一种稍弱的同步机制，即<code>volatile变量</code>，用来确保将变量的更新操作通知到其他线程。</p>
<p>当把变量声明为<code>volatile</code>类型后，编译器于运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起<code>重排序</code>。</p>
<p>volatile变量不会缓存到寄存器或者其他处理器不可见的地方，因此在<strong>读取volatile变量的时候总会返回最新写入的值</strong>。</p>
<p>volatile变量对<strong>可见性</strong>的影响比volatile变量本身更为重要。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前的对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。</p>
<p>因此，从内存可见性的角度来看，写入volatile变量相当于退出了代码块，而读取volatile变量就相当于进入了代码块。</p>
<p>虽然volatile变量很方便，但是也存在一定的局限性。<strong>因为volatile变量只能确保可见性而不确保原子性</strong>。而加锁机制则确保了原子性和可见性。</p>
<p>当且仅当满足以下所有条件时候，才应该使用volatile变量：</p>
<ol>
<li><p>对变量的写入操作不依赖于变量的当前值，或者你能确保只有单个线程更新变量的值。</p>
</li>
<li><p>该变量不会与其他状态变量一起纳入不变性条件中。</p>
</li>
<li><p>在访问变量时不需要加锁。 </p>
</li>
</ol>
<a id="more"></a>

<p>实际上在Java中已经不再推荐使用volatile关键字了，Java5增加的新特性<code>原子变量</code>提供了更加好的’读-改-写’的原子操作，并且常常作为一种<strong>更加好的volatile变量</strong>。</p>
<p><h3>更多</h3><br>请参考:<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">Java 理论与实践: 正确使用 Volatile 变量</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>Java语言提供了一种稍弱的同步机制，即<code>volatile变量</code>，用来确保将变量的更新操作通知到其他线程。</p>
<p>当把变量声明为<code>volatile</code>类型后，编译器于运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起<code>重排序</code>。</p>
<p>volatile变量不会缓存到寄存器或者其他处理器不可见的地方，因此在<strong>读取volatile变量的时候总会返回最新写入的值</strong>。</p>
<p>volatile变量对<strong>可见性</strong>的影响比volatile变量本身更为重要。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前的对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。</p>
<p>因此，从内存可见性的角度来看，写入volatile变量相当于退出了代码块，而读取volatile变量就相当于进入了代码块。</p>
<p>虽然volatile变量很方便，但是也存在一定的局限性。<strong>因为volatile变量只能确保可见性而不确保原子性</strong>。而加锁机制则确保了原子性和可见性。</p>
<p>当且仅当满足以下所有条件时候，才应该使用volatile变量：</p>
<ol>
<li><p>对变量的写入操作不依赖于变量的当前值，或者你能确保只有单个线程更新变量的值。</p>
</li>
<li><p>该变量不会与其他状态变量一起纳入不变性条件中。</p>
</li>
<li><p>在访问变量时不需要加锁。 </p>
</li>
</ol>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：用户进程和守护进程]]></title>
    <link href="http://coderxiao.com/2015/03/13/Thread-daemon/"/>
    <id>http://coderxiao.com/2015/03/13/Thread-daemon/</id>
    <published>2015-03-13T11:12:03.000Z</published>
    <updated>2015-04-20T12:28:27.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>守护线程与普通(用户)线程的唯一区别是：</p>
<p><strong>当JVM中所有的线程都是守护线程时，JVM就可以退出了；如果还有一个或以上的非守护线程则不会退出。</strong></p>
<p> (以上是针对正常退出，调用<code>System.exit</code>则必定会退出) </p>
<p>所以<code>setDeamon(true)</code>的唯一意义就是告诉JVM不需要等待它退出，让JVM喜欢什么退出就退出吧，不用管它。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>JVM的垃圾回收、内存管理等线程都是守护线程。</li>
<li>还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</li>
</ul>
<a id="more"></a>

<h2>例子</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/***</span></div><div class="line"> * 用户线程和守护线程</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserOrDaemon</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Thread t1 = <span class="keyword">new</span> MyCommon();</div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyDaemon());</div><div class="line">		t2.setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置为守护线程</span></div><div class="line"></div><div class="line">		t2.start();</div><div class="line">		t1.start();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyCommon extends Thread {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</div><div class="line">			System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				Thread.sleep(<span class="number">7</span>);</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyDaemon implements Runnable {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">9999999</span>L; i++) {</div><div class="line">			System.out.println(<span class="string">"后台线程第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				Thread.sleep(<span class="number">7</span>);</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">后台线程第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">1</span>次执行！</div><div class="line">后台线程第<span class="number">1</span>次执行！</div><div class="line">后台线程第<span class="number">2</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">2</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">3</span>次执行！</div><div class="line">后台线程第<span class="number">3</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">4</span>次执行！</div><div class="line">后台线程第<span class="number">4</span>次执行！</div><div class="line">后台线程第<span class="number">5</span>次执行！</div></pre></td></tr></table></figure>

<p>从上面的执行结果可以看出：<strong>前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>守护线程与普通(用户)线程的唯一区别是：</p>
<p><strong>当JVM中所有的线程都是守护线程时，JVM就可以退出了；如果还有一个或以上的非守护线程则不会退出。</strong></p>
<p> (以上是针对正常退出，调用<code>System.exit</code>则必定会退出) </p>
<p>所以<code>setDeamon(true)</code>的唯一意义就是告诉JVM不需要等待它退出，让JVM喜欢什么退出就退出吧，不用管它。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>JVM的垃圾回收、内存管理等线程都是守护线程。</li>
<li>还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</li>
</ul>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：同步和锁]]></title>
    <link href="http://coderxiao.com/2015/03/10/Thread-synchronize-lock/"/>
    <id>http://coderxiao.com/2015/03/10/Thread-synchronize-lock/</id>
    <published>2015-03-10T13:26:56.000Z</published>
    <updated>2015-04-20T11:34:31.000Z</updated>
    <content type="html"><![CDATA[<h2>为何需要同步和锁</h2>

<hr>
<p>看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">	</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 返回一个唯一的数值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(){</div><div class="line">		<span class="keyword">return</span> value++;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个类存在的问题是如果执行时机不对，那么两个线程在调用getNext方法时候会得到相同的值。具体过程如下：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/unsafeThread.png" alt=""></p>
<a id="more"></a>


<p>当执行某个方法的正确性取决于多个线程的交替执行时序时候，那么就会发生<code>竞态条件</code>。</p>
<p>而线程的同步和锁就是为了解决竞态条件而出现的，它可以防止多个线程访问同一个数据对象时候对数据造成的破坏。</p>
<h2>要点</h2>

<hr>
<p>每一个Java对象都有一个可重入的内置锁，这里的可重入不是Linux里面的函数重入，而是以线程为粒度，线程自身重入。</p>
<p>当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。</p>
<p>当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。</p>
<p>一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。</p>
<p>释放锁是指持锁线程退出了synchronized同步方法或代码块。</p>
<p>关于锁和同步，有一下几个要点：</p>
<ol>
<li>只能同步方法，而不能同步变量和类；</li>
<li>每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？</li>
<li>不必同步类中所有的方法，类可以同时拥有同步和非同步方法。</li>
<li>如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。</li>
<li>如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。</li>
<li>线程睡眠时，它所持的任何锁都不会释放。</li>
<li>线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。</li>
<li>同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。</li>
<li>在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。</li>
</ol>
<h2>同步方法和同步块</h2>

<hr>
<p><code>同步方法</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getX</span>() {</div><div class="line">    <span class="keyword">return</span> x++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Java提供了粒度更加细的<code>同步块</code>，可以实现和同步方法一样的效果，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span>() {</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">return</span> x++;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>要<code>同步静态方法</code>，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setName</span>(String name){</div><div class="line">      Xxx.name = name;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setName</span>(String name){</div><div class="line">      <span class="keyword">synchronized</span>(Xxx.class){</div><div class="line">            Xxx.name = name;</div><div class="line">      }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当考虑阻塞时，一定要注意哪个对象正被用于锁定：</p>
<ol>
<li><p>调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</p>
</li>
<li><p>调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。</p>
</li>
<li><p>静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p>
</li>
<li><p>对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。</p>
</li>
</ol>
<p>无论何时都要记住<strong>synchronized锁住的总是对象而不是代码</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Sync {  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span>() {  </div><div class="line">        System.out.println(<span class="string">"test开始.."</span>);  </div><div class="line">        <span class="keyword">try</span> {  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">        } <span class="keyword">catch</span> (InterruptedException e) {  </div><div class="line">            e.printStackTrace();  </div><div class="line">        }  </div><div class="line">        System.out.println(<span class="string">"test结束.."</span>);  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line">class MyThread extends Thread {  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  </div><div class="line">        Sync sync = <span class="keyword">new</span> Sync();  </div><div class="line">        sync.test();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {  </div><div class="line">            Thread thread = <span class="keyword">new</span> MyThread();  </div><div class="line">            thread.start();  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test开始..</div><div class="line">test开始..</div><div class="line">test开始..</div><div class="line">test结束..</div><div class="line">test结束..</div><div class="line">test结束..</div></pre></td></tr></table></figure>

<p>明显结果不是想要的，那么应该改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">class Sync {  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>() {  </div><div class="line">        <span class="keyword">synchronized</span> (Sync.class) {  </div><div class="line">            System.out.println(<span class="string">"test开始.."</span>);  </div><div class="line">            <span class="keyword">try</span> {  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {  </div><div class="line">                e.printStackTrace();  </div><div class="line">            }  </div><div class="line">            System.out.println(<span class="string">"test结束.."</span>);  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line">class MyThread extends Thread {  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {  </div><div class="line">        Sync sync = <span class="keyword">new</span> Sync();  </div><div class="line">        sync.test();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {  </div><div class="line">            Thread thread = <span class="keyword">new</span> MyThread();  </div><div class="line">            thread.start();  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}  </div><div class="line"></div><div class="line"><span class="javadoc">/***</span></div><div class="line"> * </div><div class="line">或者改为让三个线程使用同一个Sync的对象</div><div class="line">class MyThread extends Thread {  </div><div class="line">  </div><div class="line">    private Sync sync;  </div><div class="line">  </div><div class="line">    public MyThread(Sync sync) {  </div><div class="line">        this.sync = sync;  </div><div class="line">    }  </div><div class="line">  </div><div class="line">    public void run() {  </div><div class="line">        sync.test();  </div><div class="line">    }  </div><div class="line">}  </div><div class="line">  </div><div class="line">public class Main {  </div><div class="line">  </div><div class="line">    public static void main(String[] args) {  </div><div class="line">        Sync sync = new Sync();  </div><div class="line">        for (int i = 0; i &lt; 3; i++) {  </div><div class="line">            Thread thread = new MyThread(sync);  </div><div class="line">            thread.start();  </div><div class="line">        }  </div><div class="line">    }  </div><div class="line">}  </div><div class="line"> *</div><div class="line"> */</div></pre></td></tr></table></figure>

<p>这里使用<strong>synchronized(Sync.class)实现了全局锁对象的效果</strong></p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test开始..</div><div class="line">test结束..</div><div class="line">test开始..</div><div class="line">test结束..</div><div class="line">test开始..</div><div class="line">test结束..</div></pre></td></tr></table></figure>

<h2>同步机制</h2>

<hr>
<p>Java最初提供了<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>方法来进行同步机制。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> notify()    </div><div class="line">                    唤醒在此对象监视器上等待的单个线程。    </div><div class="line"><span class="keyword">void</span> notifyAll()    </div><div class="line">                    唤醒在此对象监视器上等待的所有线程。    </div><div class="line"><span class="keyword">void</span> wait()    </div><div class="line">                    导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。    </div><div class="line"><span class="keyword">void</span> wait(<span class="keyword">long</span> timeout)    </div><div class="line">                    导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。    </div><div class="line"><span class="keyword">void</span> wait(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)    </div><div class="line">                    导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</div></pre></td></tr></table></figure>

<p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都是Object的实例方法。</p>
<p>Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。</p>
<p>从功能上来说<strong>wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行</strong>。</p>
<p>相应的n<strong>otify()就是对对象锁的唤醒操作</strong>。</p>
<p>但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，<strong>JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程</strong>，继续执行。</p>
<p>这样就提供了在线程间同步、唤醒的操作。</p>
<p>Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于<strong>Object.wait()在释放CPU同时，释放了对象锁的控制</strong>。</p>
<p>另外需要注意的是直接在线程中调用wait(),notify()方法，那么这个对象就是当前的线程，因此在一个线程中不能自己wait()和notify()。</p>
<h3>例子</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/***</span></div><div class="line"> * 同步机制：wait和notify</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Object a = <span class="keyword">new</span> Object();</div><div class="line">		ThreadB b = <span class="keyword">new</span> ThreadB(a);</div><div class="line">		<span class="comment">// 启动计算线程</span></div><div class="line">		b.start();</div><div class="line">		<span class="comment">//线程A拥有b对象上的锁。</span></div><div class="line">		<span class="comment">//线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者</span></div><div class="line"></div><div class="line">		<span class="keyword">synchronized</span> (a) { <span class="comment">// 这里也可以是b，然后ThreadB里面直接notify即可</span></div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				System.out.println(<span class="string">"等待对象b完成计算。。。"</span>);</div><div class="line">				<span class="comment">// 当前线程A等待</span></div><div class="line">				a.wait();</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">			System.out.println(<span class="string">"b对象计算的总和是："</span> + b.total);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 计算1+2+3 ... +100的和</div><div class="line"> * </div><div class="line"> */</div><div class="line">class ThreadB extends Thread {</div><div class="line"></div><div class="line">	<span class="keyword">int</span> total;</div><div class="line">	<span class="keyword">private</span> Object a;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">ThreadB</span>(Object a) {</div><div class="line">		<span class="keyword">this</span>.a = a;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">synchronized</span> (a) {</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) {</div><div class="line">				total += i;</div><div class="line">			}</div><div class="line">			<span class="comment">// （完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒</span></div><div class="line">			<span class="comment">// 注意，这里一定是a，除非锁的是 ThreadB b ，此时可以是notify()</span></div><div class="line">			a.notify(); </div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">等待对象b完成计算。。。</div><div class="line">b对象计算的总和是：<span class="number">5050</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>为何需要同步和锁</h2>

<hr>
<p>看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span></span>{</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">	</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 返回一个唯一的数值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span>(){</div><div class="line">		<span class="keyword">return</span> value++;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个类存在的问题是如果执行时机不对，那么两个线程在调用getNext方法时候会得到相同的值。具体过程如下：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/unsafeThread.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：抢占]]></title>
    <link href="http://coderxiao.com/2015/03/04/Thread-join/"/>
    <id>http://coderxiao.com/2015/03/04/Thread-join/</id>
    <published>2015-03-04T11:26:14.000Z</published>
    <updated>2015-04-19T14:25:38.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>join可以理解成为强行抢占资源，谁调用join()谁抢占资源就先运行，要么运行完，要么设置占用资源时间。</p>
<p>join为非静态方法，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> join()    </div><div class="line">    等待该线程终止。    </div><div class="line"><span class="keyword">void</span> join(<span class="keyword">long</span> millis)    </div><div class="line">    等待该线程终止的时间最长为 millis 毫秒。    </div><div class="line"><span class="keyword">void</span> join(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)    </div><div class="line">    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</div></pre></td></tr></table></figure>

<p>join（）方法使等待当前Thread对象完成线程,例如thread1.join()表示等这个线程结束再执行下一个线程，而且，使用join()方法，必须注意顺序，打个比方：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">thread2.start();</div><div class="line">thread2.<span class="keyword">join</span>(); </div><div class="line">thread1.start();</div></pre></td></tr></table></figure>

<p>这样的顺序join()方法才有用,如果使用：           </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">thread2.<span class="keyword">join</span>();</div></pre></td></tr></table></figure>

<p>这样的顺序没有改变什么！完全没有发挥join()方法的特点。</p>
<a id="more"></a>


<h2>测试</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/***</span></div><div class="line"> * Java多线程—抢占</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>{</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">          Thread t1 = <span class="keyword">new</span> JoinThread(<span class="string">"AA"</span>);</div><div class="line">          t1.start();</div><div class="line">          <span class="keyword">try</span>{</div><div class="line">                t1.join(<span class="number">500</span>);                 <span class="comment">//Join在这里~</span></div><div class="line">          } <span class="keyword">catch</span>(InterruptedException e) {</div><div class="line">                e.printStackTrace();</div><div class="line">          }      </div><div class="line">          System.out.println(<span class="string">"over"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"> class JoinThread extends Thread{</div><div class="line">    <span class="keyword">public</span> <span class="title">JoinThread</span>(String name){</div><div class="line">          <span class="keyword">super</span>(name);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++){</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">long</span> k=<span class="number">0</span>; k&lt;<span class="number">100000000</span>; k++){}</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">": "</span> +i);</div><div class="line">          }</div><div class="line">    }</div></pre></td></tr></table></figure>

<h3>输出结果</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AA: <span class="number">0</span></div><div class="line">AA: <span class="number">1</span></div><div class="line">AA: <span class="number">2</span></div><div class="line">AA: <span class="number">3</span></div><div class="line">AA: <span class="number">4</span></div><div class="line">AA: <span class="number">5</span></div><div class="line">AA: <span class="number">6</span></div><div class="line">over</div><div class="line">AA: <span class="number">7</span></div><div class="line">AA: <span class="number">8</span></div><div class="line">AA: <span class="number">9</span></div></pre></td></tr></table></figure>

<p>但是如果把 t.join(500) 改成 t.join() 的话输出结果会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AA: <span class="number">0</span></div><div class="line">AA: <span class="number">1</span></div><div class="line">AA: <span class="number">2</span></div><div class="line">AA: <span class="number">3</span></div><div class="line">AA: <span class="number">4</span></div><div class="line">AA: <span class="number">5</span></div><div class="line">AA: <span class="number">6</span></div><div class="line">AA: <span class="number">7</span></div><div class="line">AA: <span class="number">8</span></div><div class="line">AA: <span class="number">9</span></div><div class="line">over</div></pre></td></tr></table></figure>

<p>这样子就很明显了，<code>t.join(int wait_time)</code>;后面的代码想要执行需要满足以下条件之一：<br>1、<code>线程t死了</code>；<br>2、<code>等待时间超过wait_time</code>；</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>join可以理解成为强行抢占资源，谁调用join()谁抢占资源就先运行，要么运行完，要么设置占用资源时间。</p>
<p>join为非静态方法，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> join()    </div><div class="line">    等待该线程终止。    </div><div class="line"><span class="keyword">void</span> join(<span class="keyword">long</span> millis)    </div><div class="line">    等待该线程终止的时间最长为 millis 毫秒。    </div><div class="line"><span class="keyword">void</span> join(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)    </div><div class="line">    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</div></pre></td></tr></table></figure>

<p>join（）方法使等待当前Thread对象完成线程,例如thread1.join()表示等这个线程结束再执行下一个线程，而且，使用join()方法，必须注意顺序，打个比方：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">thread2.start();</div><div class="line">thread2.<span class="keyword">join</span>(); </div><div class="line">thread1.start();</div></pre></td></tr></table></figure>

<p>这样的顺序join()方法才有用,如果使用：           </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">thread2.start();</div><div class="line">thread1.start();</div><div class="line">thread2.<span class="keyword">join</span>();</div></pre></td></tr></table></figure>

<p>这样的顺序没有改变什么！完全没有发挥join()方法的特点。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：让步]]></title>
    <link href="http://coderxiao.com/2015/03/02/Thread-yield/"/>
    <id>http://coderxiao.com/2015/03/02/Thread-yield/</id>
    <published>2015-03-02T12:32:46.000Z</published>
    <updated>2015-04-19T14:11:35.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>线程的让步的概念就是使当前运行着线程让出CPU资源，但是<strong>让给谁不知道</strong>，仅仅是让出，并且<strong>让出的时间是不可设定的</strong>，当前线程状态从运行状态回到可运行状态。</p>
<p>线程的让步使用<code>Thread.yield()</code>方法，<code>yield()</code>为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，<br>则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为“退让”，它把运行机会让给了同等级的其他线程。</p>
<p>sleep 方法允许较低优先级的线程获得运行机会，但yield（）方法执行时，当前线程仍处在可运行状态，<br>所以不可能让出较低优先级的线程此时获取CPU占有权。</p>
<p>在一个运行系统中，如果较高优先级的线程没有调用sleep方法，也没有受到I/O阻塞，<br>那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。</p>
<p>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上<br>又被执行，所以yield()方法只能使同优先级的线程有执行的机会。</p>
<p>和sleep一样，yield()也不会释放锁标志。</p>
<p>因此要<strong>谨慎在同步环境中使用yield</strong>，因为它没有释放锁，其他线程还在等待。</p>
<a id="more"></a>


<h2>测试</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Java多线程—让步</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Thread t1 = <span class="keyword">new</span> MyThread1();</div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</div><div class="line"></div><div class="line">		t2.start();</div><div class="line">		t1.start();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyThread1 extends Thread {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">			System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyRunnable implements Runnable {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">			System.out.println(<span class="string">"线程2第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">			Thread.yield();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>输出结果</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">线程<span class="number">2</span>第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">1</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">1</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">2</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">2</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">3</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">3</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">4</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">4</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">5</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">5</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">6</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">6</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">7</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">7</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">8</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">8</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">9</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">9</span>次执行！</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>线程的让步的概念就是使当前运行着线程让出CPU资源，但是<strong>让给谁不知道</strong>，仅仅是让出，并且<strong>让出的时间是不可设定的</strong>，当前线程状态从运行状态回到可运行状态。</p>
<p>线程的让步使用<code>Thread.yield()</code>方法，<code>yield()</code>为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，<br>则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为“退让”，它把运行机会让给了同等级的其他线程。</p>
<p>sleep 方法允许较低优先级的线程获得运行机会，但yield（）方法执行时，当前线程仍处在可运行状态，<br>所以不可能让出较低优先级的线程此时获取CPU占有权。</p>
<p>在一个运行系统中，如果较高优先级的线程没有调用sleep方法，也没有受到I/O阻塞，<br>那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。</p>
<p>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上<br>又被执行，所以yield()方法只能使同优先级的线程有执行的机会。</p>
<p>和sleep一样，yield()也不会释放锁标志。</p>
<p>因此要<strong>谨慎在同步环境中使用yield</strong>，因为它没有释放锁，其他线程还在等待。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：睡眠]]></title>
    <link href="http://coderxiao.com/2015/02/25/Thread-sleep/"/>
    <id>http://coderxiao.com/2015/02/25/Thread-sleep/</id>
    <published>2015-02-25T01:32:15.000Z</published>
    <updated>2015-04-19T14:01:22.000Z</updated>
    <content type="html"><![CDATA[<h2>概念</h2>

<hr>
<p>线程睡眠是使线程让出CPU的最简单的做法之一，线程睡眠的时候，会将CPU资源交给其他线程，以便能轮换执行，当睡眠一定时间后，线程会苏醒，进入可运行状态，而不是运行状态。</p>
<p>例如有两个线程同时执行(没有synchronized)一个线程优先级为<code>MAX_PRIORITY</code>，另一个为<code>MIN_PRIORITY</code>，如果没有sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。</p>
<p>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</p>
<p>线程睡眠的方法是<code>Thread.sleep(long millis)</code> 和<code>Thread.sleep(long millis, int nanos)</code>，均为静态方法。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。</p>
<p>那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就睡眠哪个线程，即只能控制当前正在运行的线程。</p>
<p>虽然sleep使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有<code>synchronized</code>同步块，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。</p>
<p>因此要<strong>谨慎在同步环境中使用sleep</strong>，因为它没有释放锁，其他线程还在等待。</p>
<a id="more"></a>

<h2>测试1</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Java多线程—睡眠</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Thread t1 = <span class="keyword">new</span> MyThread1();</div><div class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyThread1 extends Thread {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</div><div class="line">			System.out.println(<span class="string">"线程1第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				Thread.sleep(<span class="number">50</span>);</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class MyRunnable implements Runnable {</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</div><div class="line">			System.out.println(<span class="string">"线程2第"</span> + i + <span class="string">"次执行！"</span>);</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				Thread.sleep(<span class="number">50</span>);</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>输出结果</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">线程<span class="number">1</span>第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">0</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">1</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">1</span>次执行！</div><div class="line">线程<span class="number">2</span>第<span class="number">2</span>次执行！</div><div class="line">线程<span class="number">1</span>第<span class="number">2</span>次执行！</div></pre></td></tr></table></figure>

<h2>测试2</h2>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/***</span></div><div class="line"> * 同步环境中使用sleep</div><div class="line"> * 测试线程sleep时候不会释放锁</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Lock lock;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Sleep</span>() {</div><div class="line"></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Sleep</span>(String name, Lock lock) {</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.lock = lock;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		lock.lock();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i);</div><div class="line">			<span class="keyword">try</span> {</div><div class="line">				<span class="comment">// 注意，这里sleep是不会释放锁的，所以依然会按照顺序执行</span></div><div class="line">				Thread.currentThread().sleep(<span class="number">1000</span>);</div><div class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">				e.printStackTrace();</div><div class="line">			}</div><div class="line">		}</div><div class="line">		lock.unlock();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line"></div><div class="line">		<span class="comment">// 使用锁，后面会讲到</span></div><div class="line">		Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">		Sleep[] list = <span class="keyword">new</span> Sleep[<span class="number">2</span>];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) {</div><div class="line">			list[i] = <span class="keyword">new</span> Sleep(<span class="string">"thread"</span> + i, lock);</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) {</div><div class="line">			list[i].start();</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>输出结果</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">thread0	<span class="number">0</span></div><div class="line">thread0	<span class="number">1</span></div><div class="line">thread0	<span class="number">2</span></div><div class="line">thread0	<span class="number">3</span></div><div class="line">thread0	<span class="number">4</span></div><div class="line">thread1	<span class="number">0</span></div><div class="line">thread1	<span class="number">1</span></div><div class="line">thread1	<span class="number">2</span></div><div class="line">thread1	<span class="number">3</span></div><div class="line">thread1	<span class="number">4</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>概念</h2>

<hr>
<p>线程睡眠是使线程让出CPU的最简单的做法之一，线程睡眠的时候，会将CPU资源交给其他线程，以便能轮换执行，当睡眠一定时间后，线程会苏醒，进入可运行状态，而不是运行状态。</p>
<p>例如有两个线程同时执行(没有synchronized)一个线程优先级为<code>MAX_PRIORITY</code>，另一个为<code>MIN_PRIORITY</code>，如果没有sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。</p>
<p>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</p>
<p>线程睡眠的方法是<code>Thread.sleep(long millis)</code> 和<code>Thread.sleep(long millis, int nanos)</code>，均为静态方法。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。</p>
<p>那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就睡眠哪个线程，即只能控制当前正在运行的线程。</p>
<p>虽然sleep使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有<code>synchronized</code>同步块，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。</p>
<p>因此要<strong>谨慎在同步环境中使用sleep</strong>，因为它没有释放锁，其他线程还在等待。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：状态转换图]]></title>
    <link href="http://coderxiao.com/2015/02/18/Thread-status/"/>
    <id>http://coderxiao.com/2015/02/18/Thread-status/</id>
    <published>2015-02-18T04:03:42.000Z</published>
    <updated>2015-04-19T13:30:36.000Z</updated>
    <content type="html"><![CDATA[<h2>线程的状态</h2>

<hr>
<p>线程的状态转换是线程控制的基础。线程状态总的可以分为五大状态，分别是：<code>生</code>、<code>死</code>、<code>可运行</code>、<code>运行</code>、<code>等待/阻塞/睡眠</code>。</p>
<p>可以用一个图来描述如下：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/thread_status.jpg" alt=""></p>
<a id="more"></a>

<ol>
<li><p><code>新状态</code>：线程对象已经创建，还没有在其上调用start()方法。</p>
</li>
<li><p><code>可运行状态</code>：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</p>
</li>
<li><p><code>运行状态</code>：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
</li>
<li><p><code>等待/阻塞/睡眠状态</code>：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，它可能返回到可运行状态。</p>
</li>
<li><p><code>死亡态</code>：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2>线程的状态</h2>

<hr>
<p>线程的状态转换是线程控制的基础。线程状态总的可以分为五大状态，分别是：<code>生</code>、<code>死</code>、<code>可运行</code>、<code>运行</code>、<code>等待/阻塞/睡眠</code>。</p>
<p>可以用一个图来描述如下：</p>
<p><img src="http://7tsz8h.com1.z0.glb.clouddn.com/thread_status.jpg" alt=""></p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多线程：创建和启动]]></title>
    <link href="http://coderxiao.com/2015/02/15/Thread-create/"/>
    <id>http://coderxiao.com/2015/02/15/Thread-create/</id>
    <published>2015-02-15T10:17:08.000Z</published>
    <updated>2015-04-19T13:03:52.000Z</updated>
    <content type="html"><![CDATA[<h2>创建线程</h2>

<hr>
<p>Java中创建线程有两种方法：</p>
<ol>
<li><p>扩展<code>java.lang.Thread</code>类</p>
</li>
<li><p>实现<code>java.lang.Runnable</code>接口</p>
</li>
</ol>
<h3>扩展java.lang.Thread类</h3>

<p>这个类中有一个run()方法，子类只需要重写该方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</div></pre></td></tr></table></figure>

<h3>实现java.lang.Runnable接口</h3>

<p>实现这个接口的类需要实现run方法,同上</p>
<a id="more"></a>

<h2>启动线程</h2>

<hr>
<p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p>
<p>在调用start()方法之前：线程处于新状态中，新状态指向一个Thread对象，但还没有一个真正的线程。</p>
<p>在调用start()方法之后：发生了一系列复杂的事情：</p>
<ol>
<li><p><code>启动新的执行线程（具有新的调用栈）</code></p>
</li>
<li><p><code>该线程从新状态转移到可运行状态</code></p>
</li>
<li><p><code>当该线程获得机会执行时，其目标run()方法将运行</code></p>
</li>
</ol>
<p>注意：对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称(和签名)。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。若在main主线程中直接调用run方法，那么将会阻塞主线程，直到run方法执行完毕。</p>
<h2>例子</h2>

<hr>
<h4>继承Thread类，重写run方法，并调用start方法启动线程</h4>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2Methods</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">Thread2Methods</span>(String name) {</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@Override</span> </div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</div><div class="line">				System.out.println(Thread.currentThread().getName());</div><div class="line">				<span class="keyword">try</span> {</div><div class="line">					Thread.sleep(i*<span class="number">1000</span>);</div><div class="line">				} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">					e.printStackTrace();</div><div class="line">				}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Thread2Methods thread1 = <span class="keyword">new</span> Thread2Methods(<span class="string">"线程1"</span>);</div><div class="line">		Thread2Methods thread2 = <span class="keyword">new</span> Thread2Methods(<span class="string">"线程2"</span>);</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4>实现Runnable接口,重写run方法，并把这个接口类作为Thread类的构造函数参数创建一个线程，并调用start方法</h4>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2Methods</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span> </div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++){</div><div class="line">				System.out.println(Thread.currentThread().getName());</div><div class="line">				<span class="keyword">try</span> {</div><div class="line">					Thread.sleep(i*<span class="number">1000</span>);</div><div class="line">				} <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">					e.printStackTrace();</div><div class="line">				}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2Methods(),<span class="string">"线程1"</span>);</div><div class="line">		Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2Methods(),<span class="string">"线程2"</span>);</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3>输出结果</h3>

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">线程<span class="number">2</span></div><div class="line">线程<span class="number">1</span></div><div class="line">线程<span class="number">2</span></div><div class="line">线程<span class="number">1</span></div><div class="line">线程<span class="number">1</span></div><div class="line">线程<span class="number">2</span></div><div class="line">线程<span class="number">1</span></div><div class="line">线程<span class="number">2</span></div><div class="line">线程<span class="number">2</span></div><div class="line">线程<span class="number">1</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2>创建线程</h2>

<hr>
<p>Java中创建线程有两种方法：</p>
<ol>
<li><p>扩展<code>java.lang.Thread</code>类</p>
</li>
<li><p>实现<code>java.lang.Runnable</code>接口</p>
</li>
</ol>
<h3>扩展java.lang.Thread类</h3>

<p>这个类中有一个run()方法，子类只需要重写该方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</div></pre></td></tr></table></figure>

<h3>实现java.lang.Runnable接口</h3>

<p>实现这个接口的类需要实现run方法,同上</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://coderxiao.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://coderxiao.com/tags/Thread/"/>
    
      <category term="Java" scheme="http://coderxiao.com/categories/Java/"/>
    
  </entry>
  
</feed>
